#ifndef SHOW_MST_CPP
#define SHOW_MST_CPP

//---------------------------------------------------------------------------
//
// Copyright (c) Miami University, Oxford, OHIO.
// All rights reserved.
//
// Miami University (MU) makes no representations or warranties about
// the suitability of the software, either express or implied,
// including but not limited to the implied warranties of
// merchantability, fitness for a particular purpose, or
// non-infringement.  MU shall not be liable for any damages suffered
// by licensee as a result of using, result of using, modifying or
// distributing this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of this license.
//
// Authors: Dhananjai M. Rao       raodm@muohio.edu
//
//---------------------------------------------------------------------------

#include "ShowMST.h"
#include "Common.h"
#include "EST.h"
#include "ESTList.h"
#include "ArgParser.h"

#include <algorithm>

// The minimum spacing between nodes in the tree.
#define MIN_SPC 100

// Redefine the default font size (in points) to use
#undef  FONT_SIZE
#define FONT_SIZE 10

int
ShowMST::main(int argc, char *argv[]) {
    std::string mstFileName; // MST data file with PEACE-generated MST data
    std::string estFileName; // File with ESTs associated with MST
    std::string outFileName; // Output file with bracketed-MST.
    std::string clstrFileName; // Cluster output data file from PEACE
    bool showOptions    = false;
    bool showIndexOnly  = false;
    double xScale       = 5.0;
    double yScale       = 1.5;
    
    // Create the list of valid arguments to be used by the arg_parser.
    ArgParser::ArgRecord arg_list[] = {
        {"--mstFile", "MST file generated by PEACE",
         &mstFileName, ArgParser::STRING},
        {"--estFile", "File with ESTs corresponding to nodes in MST",
         &estFileName, ArgParser::STRING},
        {"--output", "File to which the bracketed MST must be written",
         &outFileName, ArgParser::STRING},
        {"--clstrFile", "Optional clusters output from PEACE for color coding",
         &clstrFileName, ArgParser::STRING},        
        {"--xScale", "X-Scale for emphasizing line lengths",
         &xScale, ArgParser::DOUBLE},
        {"--yScale", "Y-Scale for vert. spacing between entries",
         &yScale, ArgParser::DOUBLE},
        {"--idxOnly", "Show only index values for each ESt in MST",
         &showIndexOnly, ArgParser::BOOLEAN},
        {"--options", "Lists options for this tool",
         &showOptions, ArgParser::BOOLEAN},
        {"", "", NULL, ArgParser::INVALID}
    };
    
    // Get the argument parser to parse and consume the global
    // options.  Based on the options supplied, various variables will
    // be set to appropriate values.
    ArgParser ap;
    Tool::addCmdLineArgs("ShowAlignment", ap);
    ap.addValidArguments(arg_list);
    ap.parseArguments(argc, argv, false);
    if (showOptions) {
        std::cout << ap << std::endl;
        // Nothing further to be done.
        return 0;
    }
    // Ensure we have all the necessary parameters.
    std::string tool = "ShowMST";
    CHECK_ARGS(tool, mstFileName.empty(), "MST file generated by PEACE was " \
               "not specified.\nUse --mstFile option\n");
    CHECK_ARGS(tool, estFileName.empty(), "FASTA file to load ESTs was not " \
               "specified.\nUse --estFile option\n");
    CHECK_ARGS(tool, outFileName.empty(), "Output bracketed MST file was not " \
               "specified.\n Use --output option\n");
    
    // OK, create an object for further processing.
    ShowMST showMST(xScale, yScale, showIndexOnly);
    // Try and load the MST data first.
    if (!showMST.loadMSTdata(mstFileName.c_str(), false, true)) {
        // Error occured. Can't proceed further.
        return 1;
    }
    // Try and load the source file
    if (!showMST.loadFastaFile(estFileName)) {
        // All the sequences could not be loaded.
        return 2;
    }
    if (!clstrFileName.empty()&& (!showMST.loadClusterInfo(clstrFileName))) {
        std::cout << "Unable to read data from cluster file "
                  << clstrFileName << ".\n";
        return 4;
    }
    // Try to open the output file.
    if (!showMST.xfig.setOutput(outFileName, true)) {
        std::cout << "Unable to open output file " << outFileName
                  << " for output.\n";
        return 3;
    } 
    // OK, draw the tree now.
    int endY = 0;
    showMST.drawNode(showMST.getRoot(), 0, 0, endY);
    // Everything went well.
    return 0;
}

int
ShowMST::drawNode(const MSTguiNode& node,
                  const int startX, const int startY, int& endY) {
    // Binary search & locate the first node in the MST for which the
    // given node is the parent.
    std::vector<MSTguiNode>::const_iterator child =
        getFirstChild(node.estIdx);
    if (child == mst.end()) {
        // No child entries found.  This is a leaf node.
        return drawESTinfo(node, startX, startY, endY);
    }
    // Compute font characteristics to properly align text.
    const int FontHeight= (int) (1200.0 * FONT_SIZE / 72);
    const int FontWidth = FontHeight * 65 / 100;    
    // Determine label for this node with just first 10 characters
    std::string label   = getESTId(node, 10);
    int labelSize       = label.size() * FontWidth;
    // First dump out all our children.
    const int childX    = (int) (startX + MIN_SPC + labelSize +
                                 (node.metric * xScale));
    int topChildY       = 0, bottomChildY = 0;
    endY                = startY;
    bool firstChild     = true;
    
    // Iterate over child nodes and print them first.
    while ((child != mst.end()) && (child->parentIdx == node.estIdx)) {
        // Recursively draw child.
        bottomChildY = drawNode(*child, childX, endY, endY);
        // Note where the first child got rendered.
        if (firstChild) {
            // Track topChildY for first child only.
            topChildY  = bottomChildY;
            firstChild = false;
        }
        // Onto the next child (if any)
        child++;
    }
    
    // Now that all the children have been dumped draw a vertical line
    // connecting them all.
    xfig.drawLine(childX, topChildY, childX, bottomChildY);
    // Do a horizonal line with text in the middle for this non-leaf node.
    const int midY   = (topChildY + bottomChildY) / 2;
    const int labelX = (int) (startX + (MIN_SPC / 2) + (node.metric * xScale));
    xfig.drawLine(startX, midY, labelX, midY);
    xfig.drawText(label, labelX, midY - (FontHeight / 2),
                  COURIER, FONT_SIZE, getColor(node.estIdx));
    xfig.drawLine(labelX + labelSize, midY, childX, midY);
    // Return mid point of sub-tree back to the caller.
    return midY;
}

int
ShowMST::drawESTinfo(const MSTguiNode& node,
                     const int startX, const int startY,
                     int& endY) {
    // Get EST information for this leaf node first.
    std::string info = getESTId(node, 20);
    // Draw the EST fasta info at the supplied startX & startY 
    int childX = (int) (startX + (MIN_SPC / 2) + (node.metric * xScale));
    const int textHeight = xfig.drawText(info, childX + MIN_SPC / 2, startY,
                                         COURIER, FONT_SIZE,
                                         getColor(node.estIdx));
    // Compute mid point of the text for drawing horizontal line.
    const int midY = startY + (textHeight / 2);
    xfig.drawLine(startX, midY, childX, midY);
    // Compute the ending point for this node.
    endY = (int) (startY + (textHeight * yScale));
    
    return midY;
}

std::string
ShowMST::getESTId(const MSTguiNode& node, const int maxLen) {
    // Get EST information for this leaf node first.
    const EST* est = getESTList().get(node.estIdx);
    // Get the info string.
    char buffer[16];
    sprintf(buffer, "[%d]", node.estIdx);
    std::string retVal;
    if (!showIndexOnly) {
        // add the FASTA index.
        retVal = est->getInfo();
    }
    // Prune info if needed.
    if ((maxLen != -1) && ((int) retVal.size() > maxLen)) {
        retVal = retVal.substr(0, maxLen);
        retVal += ">";  // show character for additional information
    }
    // Add on the index value.
    retVal += buffer;
    // Return a possibly abbreviated information string
    return retVal;
}

ShowMST::ShowMST(const double xScaleVal, const double yScaleVal,
                 const bool showIdxOnly) :
    xScale(xScaleVal),  yScale(yScaleVal), showIndexOnly(showIdxOnly) {
    // Nothing much to do other to initialize variables
}

ShowMST::~ShowMST() {
    // Free up any dynamically allocated memory.
}

#endif
