#ifndef SHOW_MST_CPP
#define SHOW_MST_CPP

//---------------------------------------------------------------------------
//
// Copyright (c) Miami University, Oxford, OHIO.
// All rights reserved.
//
// Miami University (MU) makes no representations or warranties about
// the suitability of the software, either express or implied,
// including but not limited to the implied warranties of
// merchantability, fitness for a particular purpose, or
// non-infringement.  MU shall not be liable for any damages suffered
// by licensee as a result of using, result of using, modifying or
// distributing this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of this license.
//
// Authors: Dhananjai M. Rao       raodm@muohio.edu
//
//---------------------------------------------------------------------------

#include "ShowMST.h"
#include "Common.h"
#include "EST.h"
#include "ESTList.h"
#include "ArgParser.h"
#include <cmath>
#include <algorithm>

// The minimum spacing between nodes in the tree.
#define MIN_SPC 100

// Redefine the default font size (in points) to use
#undef  FONT_SIZE
#define FONT_SIZE 10

int
ShowMST::main(int argc, char *argv[]) {
    std::string mstFileName; // MST data file with PEACE-generated MST data
    std::string estFileName; // File with ESTs associated with MST
    std::string pdbListFile; // File with path to PDBF files.
    std::string outFileName; // Output file with bracketed-MST.
    std::string clstrFileName; // Cluster output data file from PEACE
    std::string format = "fig";  // Outut format.
    bool showOptions    = false;
    bool showIndexOnly  = false;
    double xScale       = 5.0;
    double yScale       = 1.5;
    
    // Create the list of valid arguments to be used by the arg_parser.
    ArgParser::ArgRecord arg_list[] = {
        {"--mstFile", "MST file generated by PEACE",
         &mstFileName, ArgParser::STRING},
        {"--estFile", "File with ESTs corresponding to nodes in MST",
         &estFileName, ArgParser::STRING},
        {"--pdbListFile", "The PDB-list file with path(s) in it",
         &pdbListFile, ArgParser::STRING},
        {"--output", "File to which the bracketed MST must be written",
         &outFileName, ArgParser::STRING},
        {"--clstrFile", "Optional flat clusters output from PEACE for color coding",
         &clstrFileName, ArgParser::STRING},        
        {"--xScale", "X-Scale for emphasizing line lengths (Xfig only)",
         &xScale, ArgParser::DOUBLE},
        {"--yScale", "Y-Scale for vert. spacing between entries (Xfig only)",
         &yScale, ArgParser::DOUBLE},
        {"--idxOnly", "Show only index values for each EST in MST",
         &showIndexOnly, ArgParser::BOOLEAN},
        {"--format", "Output in 'fig' or 'dot' format", &format,
         ArgParser::STRING},
        {"--options", "Lists options for this tool",
         &showOptions, ArgParser::BOOLEAN},    
        {"", "", NULL, ArgParser::INVALID}
    };
    
    // Get the argument parser to parse and consume the global
    // options.  Based on the options supplied, various variables will
    // be set to appropriate values.
    ArgParser ap;
    Tool::addCmdLineArgs("ShowMST", ap);
    ap.addValidArguments(arg_list);
    ap.parseArguments(argc, argv, false);
    if (showOptions) {
        std::cout << ap << std::endl;
        // Nothing further to be done.
        return 0;
    }
    // Ensure we have all the necessary parameters.
    std::string tool = "ShowMST";
    CHECK_ARGS(tool, mstFileName.empty(), "MST file generated by PEACE was " \
               "not specified.\nUse --mstFile option\n");
    CHECK_ARGS(tool, estFileName.empty() && pdbListFile.empty(),
               "FASTA file to load ESTs was not "       \
               "specified.\nUse --estFile option\n");
    CHECK_ARGS(tool, outFileName.empty(), "Output bracketed MST file was not " \
               "specified.\n Use --output option\n");
    
    // OK, create an object for further processing.
    ShowMST showMST(xScale, yScale, showIndexOnly, format);
    // Try and load the MST data first.
    if (!showMST.loadMSTdata(mstFileName.c_str(), false, true)) {
        // Error occured. Can't proceed further.
        return 1;
    }
    // Try and load the source file
    if (!showMST.loadFastaFile((estFileName.empty() ? pdbListFile :estFileName),
                               (estFileName.empty() ? "pdblist" : "fasta"))) {
        // All the sequences could not be loaded.
        return 2;
    }
    if (!clstrFileName.empty()&& (!showMST.loadClusterInfo(clstrFileName))) {
        std::cout << "Unable to read data from cluster file "
                  << clstrFileName << ".\n";
        return 4;
    }

    if (format == "fig") {
        // Try to open the output file.
        if (!showMST.xfig.setOutput(outFileName, true)) {
            std::cout << "Unable to open output file " << outFileName
                      << " for output.\n";
            return 3;
        } 
        // OK, draw the tree now.
        int endY = 0;
        showMST.drawNode(showMST.getRoot(), 0, 0, endY);
    } else {
        // Have the helper method write the mst in DOT format
        return showMST.drawDotGraph(outFileName);
    }
    // Everything went well.
    return 0;
}

int
ShowMST::drawNode(const MSTguiNode& node,
                  const int startX, const int startY, int& endY) {
    // Binary search & locate the first node in the MST for which the
    // given node is the parent.
    std::vector<MSTguiNode>::const_iterator child =
        getFirstChild(node.estIdx);
    if (child == mst.end()) {
        // No child entries found.  This is a leaf node.
        return drawESTinfo(node, startX, startY, endY);
    }
    // Compute font characteristics to properly align text.
    const int FontHeight= (int) (1200.0 * FONT_SIZE / 72);
    const int FontWidth = FontHeight * 65 / 100;    
    // Determine label for this node with just first 10 characters
    std::string label   = getESTId(node, 10);
    int labelSize       = label.size() * FontWidth;
    // First dump out all our children.
    const int childX    = (int) (startX + MIN_SPC + labelSize +
                                 (node.metric * xScale));
    int topChildY       = 0, bottomChildY = 0;
    endY                = startY;
    bool firstChild     = true;
    
    // Iterate over child nodes and print them first.
    while ((child != mst.end()) && (child->parentIdx == node.estIdx)) {
        // Recursively draw child.
        bottomChildY = drawNode(*child, childX, endY, endY);
        // Note where the first child got rendered.
        if (firstChild) {
            // Track topChildY for first child only.
            topChildY  = bottomChildY;
            firstChild = false;
        }
        // Onto the next child (if any)
        child++;
    }
    
    // Now that all the children have been dumped draw a vertical line
    // connecting them all.
    xfig.drawLine(childX, topChildY, childX, bottomChildY);
    // Do a horizonal line with text in the middle for this non-leaf node.
    const int midY   = (topChildY + bottomChildY) / 2;
    const int labelX = (int) (startX + (MIN_SPC / 2) + (node.metric * xScale));
    xfig.drawLine(startX, midY, labelX, midY);
    xfig.drawText(label, labelX, midY - (FontHeight / 2),
                  COURIER, FONT_SIZE, getColor(node.estIdx));
    xfig.drawLine(labelX + labelSize, midY, childX, midY);
    // Return mid point of sub-tree back to the caller.
    return midY;
}

int
ShowMST::drawESTinfo(const MSTguiNode& node,
                     const int startX, const int startY,
                     int& endY) {
    // Get EST information for this leaf node first.
    std::string info = getESTId(node, 20);
    // Draw the EST fasta info at the supplied startX & startY 
    int childX = (int) (startX + (MIN_SPC / 2) + (node.metric * xScale));
    const int textHeight = xfig.drawText(info, childX + MIN_SPC / 2, startY,
                                         COURIER, FONT_SIZE,
                                         getColor(node.estIdx));
    // Compute mid point of the text for drawing horizontal line.
    const int midY = startY + (textHeight / 2);
    xfig.drawLine(startX, midY, childX, midY);
    // Compute the ending point for this node.
    endY = (int) (startY + (textHeight * yScale));
    
    return midY;
}

std::string
ShowMST::getESTId(const MSTguiNode& node, const int maxLen) {
    // Get EST information for this leaf node first.
    const EST* est = getESTList().get(node.estIdx);
    // Get the info string.
    char buffer[16];
    sprintf(buffer, "[%d]", node.estIdx);
    std::string retVal;
    if (!showIndexOnly) {
        // add the FASTA index.
        retVal = est->getInfo();
    }
    // Prune info if needed.
    if ((maxLen != -1) && ((int) retVal.size() > maxLen)) {
        retVal = retVal.substr(0, maxLen);
        retVal += ">";  // show character for additional information
    }
    // Add on the index value.
    retVal += buffer;
    // Return a possibly abbreviated information string
    return retVal;
}

ShowMST::ShowMST(const double xScaleVal, const double yScaleVal,
                 const bool showIdxOnly, const std::string& outFormat) :
    xScale(xScaleVal),  yScale(yScaleVal), showIndexOnly(showIdxOnly),
    outFormat(outFormat) {
    // Nothing much to do other to initialize variables
}

ShowMST::~ShowMST() {
    // Free up any dynamically allocated memory.
}

int
ShowMST::drawDotGraph(const std::string& outFileName) {
    std::ofstream dotFile(outFileName);
    if (!dotFile.good()) {
        std::cout << "Error opening file " << outFileName << std::endl;
        return 4;
    }
    // Write the pre-defined header to the file
    dotFile << "digraph mst {\n"
            << "  node[label=\"\",width=0.2,shape=\"circle\"];\n\n";
 
    // Generate edge information for each edge in the MST by walking
    // the list of nodes in the MST
    for (const MSTguiNode& node : mst) {
        if (node.parentIdx != -1) {
            dotFile << "  " << node.parentIdx << " -> " << node.estIdx
                    << " [dir=\"none\", len=" << std::max(node.metric * 2, 0.001f)
                    << "]\n";
        }
    }

    // Generate node color based on clustering for each of the nodes
    // in the MST
    int prevClsId = -1;
    for (const MSTguiNode& node : mst) {
        const int clusterId = getCluster(node.estIdx, 0);
        std::string xlabel;
        if (node.estIdx == 0) {
            xlabel = "*";
        } else if (prevClsId != clusterId) {
            // xlabel = std::to_string(clusterId);
            prevClsId = clusterId;
        }
        // std::cout << node.estIdx << ", " << clusterId << std::endl;
        dotFile << "  " << node.estIdx << "[style=\"filled\", color=\""
                << getDotNodeColor(clusterId) << "\""
                << (!xlabel.empty() ? ", xlabel=\"" + xlabel + "\"" : "")
                << "]\n";
    }
    
    dotFile << "}\n";
    // Everything went well
    return 0;
}

std::string
ShowMST::getDotNodeColor(const int clsId, const int NumColors) const {
    // To generate pastel colors, iterate through hue values and keep
    // saturation and lightness/value within certain ranges.  Pastel
    // colors are typically characterized by high lightness (or value)
    // and moderate saturation.
    const double s  = 0.5; // Moderate saturation
    const double l  = 0.8;  // High lightness
    const double h  = (360.0 / NumColors) * clsId;  // hue

    // Now convert the HSL into an rgb string.
    const double c = (1 - std::abs(2 * l - 1)) * s;
    const double x = c * (1 - std::abs(std::fmod(h / 60.0, 2) - 1));
    const double m = l - c / 2;

    double r_prime, g_prime, b_prime;

    if (h >= 0 && h < 60) {
        r_prime = c; g_prime = x; b_prime = 0;
    } else if (h >= 60 && h < 120) {
        r_prime = x; g_prime = c; b_prime = 0;
    } else if (h >= 120 && h < 180) {
        r_prime = 0; g_prime = c; b_prime = x;
    } else if (h >= 180 && h < 240) {
        r_prime = 0; g_prime = x; b_prime = c;
    } else if (h >= 240 && h < 300) {
        r_prime = x; g_prime = 0; b_prime = c;
    } else {
        r_prime = c; g_prime = 0; b_prime = x;
    }

    char rgb[16];
    const int red   = (r_prime + m) * 255;
    const int green = (g_prime + m) * 255;
    const int blue  = (b_prime + m) * 255;
    sprintf(rgb, "#%2x%2x%2x", red, green, blue);
    return rgb;
    
}

#endif
