#ifndef ALIGN_CPP
#define ALIGN_CPP

//---------------------------------------------------------------------------
//
// Copyright (c) Miami University, Oxford, OHIO.
// All rights reserved.
//
// Miami University (MU) makes no representations or warranties about
// the suitability of the software, either express or implied,
// including but not limited to the implied warranties of
// merchantability, fitness for a particular purpose, or
// non-infringement.  MU shall not be liable for any damages suffered
// by licensee as a result of using, result of using, modifying or
// distributing this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of this license.
//
// Authors: Dhananjai M. Rao       raodm@muohio.edu
//
//---------------------------------------------------------------------------

#include "Align.h"
#include "Common.h"
#include "EST.h"
#include "ESTList.h"
#include "ArgParser.h"

// A convenience macro to determine sign of a number
#define SIGN(x) ((x < 0) ? -1 : 1)

int
Align::main(int argc, char *argv[]) {
    std::string mstFileName; // MST data file with PEACE-generated MST data
    std::string estFileName; // File with ESTs associated with MST
    std::string outFileName; // Output FASTA file
    bool showOptions    = false;
    
    // Create the list of valid arguments to be used by the arg_parser.
    ArgParser::ArgRecord arg_list[] = {
        {"--mstFile", "MST file with alignment data generated by PEACE",
         &mstFileName, ArgParser::STRING},
        {"--estFile", "File with ESTs corresponding to nodes in MST",
         &estFileName, ArgParser::STRING},
        {"--output", "FASTA file to which the annotated ESTs must be written",
         &outFileName, ArgParser::STRING},
        {"--options", "Lists options for this tool",
         &showOptions, ArgParser::BOOLEAN},
        {"", "", NULL, ArgParser::INVALID}
    };
    
    // Get the argument parser to parse and consume the global
    // options.  Based on the options supplied, various variables will
    // be set to appropriate values.
    ArgParser ap;
    // Let base class add some defaults for us.
    Tool::addCmdLineArgs("ShowAlignment", ap);
    // Add our custom arguments
    ap.addValidArguments(arg_list);
    // Validate the command-line options.
    ap.parseArguments(argc, argv, false);    
    if (showOptions) {
        std::cout << ap << std::endl;
        // Nothing further to be done.
        return 0;
    }
    // Ensure we have all the necessary parameters.
    std::string tool = "Align";
    CHECK_ARGS(tool, mstFileName.empty(), "MST file generated by PEACE was " \
               "not specified.\nUse --mstFile option\n");
    CHECK_ARGS(tool, estFileName.empty(), "FASTA file to load ESTs was not " \
               "specified.\nUse --estFile option\n");
    CHECK_ARGS(tool, outFileName.empty(), "Output FASTA file was not "  \
               "specified.\n Use --output option\n");
    
    // OK, create an object for further processing.
    Align align;
    // Try and load the MST data (with alignment) and sort the nodes
    if (!align.loadMSTdata(mstFileName.c_str(), true, true)) {
        // Error occured. Can't proceed further.
        return 1;
    }
    // Try and load the source EST file
    if (!align.loadFastaFile(estFileName)) {
        // All the sequences could not be loaded.
        return 2;
    }
    // Try to open the output FASTA file.
    std::ofstream output(outFileName.c_str());
    if (!output.good()) {
        std::cout << "Unable to open output file " << outFileName
                  << " for writing.\n";
        return 3;
    } 
    // OK, do the alingment and generate annotated FASTA file.
    align.doAlignment(output);
    // Everything went well.
    return 0;
}

Align::Align() {
    // Nothing to be done in the constructor.
}

Align::~Align() {
    // Nothing to be done in the destructor.
}

void
Align::doAlignment(std::ostream &os) {
    // Now annotate ESTs using their relative positions in the MST and
    // the farthestpos value.
    const int farthestPos = getFarthestPos();
    // Now recurvisely align all the nodes start with root (-1)
    doAlignment(os, -1, -farthestPos);
}

int
Align::getFarthestPos(const int parentIdx) {
    int farthestPos = 0;
    // Binary search & locate the first node in the MST for which the
    // given node is the parent.
    std::vector<MSTguiNode>::const_iterator child =  getFirstChild(parentIdx);
    // Find the minimum of the farthestPos amongst all the children.
    while ((child != mst.end()) && (child->parentIdx == parentIdx)) {
        // Obtain child's estimate of farthest position.
        const int childPos = child->alignmentInfo +
            (child->metric * SIGN(child->alignmentInfo)) + 
            getFarthestPos(child->estIdx);
        // Select the minimum of the two.
        farthestPos = std::min<int>(farthestPos, childPos);
        // Onto the next child node.
        child++;
    }
    // return the minumum estimate.
    return farthestPos;
}

void
Align::doAlignment(std::ostream& os, const int estIdx, const int startPos) {
    // Draw this estIdx if the index is valid.
    const ESTList& estList = getESTList();
    if ((estIdx >= 0) && (estIdx < estList.size())) {
        const EST *est = estList.get(estIdx);
        ASSERT( est != NULL );
        // Buffer for temporary string storage
        char buffer[128];
        // Convert alignment information to a properly formatted string.
        sprintf(buffer,"|%d_%d", startPos,
                (int) (startPos + strlen(est->getSequence())));
        std::string header = est->getInfo();
        header            += buffer;
        // Create temporary EST object with the information
        EST annotatedEST(estIdx, header.c_str(), est->getSequence());
        // Write EST to the output fasta file.
        annotatedEST.dumpEST(os);
    }
    
    // Binary search & locate first child node in the MST for which
    // the given node is the parent.
    std::vector<MSTguiNode>::const_iterator child =  getFirstChild(estIdx);
    // Recurviely get the children to align themselves and their children
    while ((child != mst.end()) && (child->parentIdx == estIdx)) {
        // Get the child of align itself.
        doAlignment(os, child->estIdx,
                    startPos + child->alignmentInfo +
                    (SIGN(child->alignmentInfo) * child->metric));
        // Onto the next child node.
        child++;
    }
    
}

#endif
