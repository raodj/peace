package org.peace_tools.core.job.east;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;

import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;
import javax.swing.border.EmptyBorder;

import org.peace_tools.generic.GenericWizardPage;
import org.peace_tools.generic.Utilities;
import org.peace_tools.generic.WizardDialog;
import org.peace_tools.workspace.DataSet;
import org.peace_tools.workspace.Workspace;

/**
 * <p>This wizard page permits the user to specify the folder and names
 * of the various output files generated by a job. The set of 
 * files is classified into two independent tabs. The first tab
 * deals with the clustering outputs (MST and CLS file), an optional
 * tab that may not be displayed if a pure assembly job is being
 * run. The second tab deals with assembly outputs (contig file,
 * singletons, and others). A default directory path is suggested
 * for all the files to help the user to organize the data better.</p> 
 *
 */
public class OutputFilesPage extends GenericWizardPage
implements ActionListener {
	/**
	 * The constructor. The constructor sets up the various components
	 * on this wizard page. The components include a common default
	 * folder entry followed by two separate tabs with various
	 * input fields for individual file names.
	 * 
	 * @param wizard The wizard that logically owns this page.
	 * 
	 * @param clustering If this flag is true, then a separate tab
	 * for specifying path/name for files generated as output from
	 * a clustering job in included in this wizard page.
	 */
	public OutputFilesPage(EASTJobWizard wizard, boolean clustering) {
		this.wizard      = wizard;
		// this.alsoCluster = clustering;
		assert(this.wizard != null);
		// Setup the title(s) for this page and border
		setTitle("Output File", 
				"Set path and names for output files");
		setBorder(new EmptyBorder(5, 5, 5, 5));
		
		// Create the default path entry box.
		JPanel defaultPath = createFileInput(0, DEFAULT_PATH_INFO, 
				DEFAULT_PATH_TOOL_TIP, true);
		// Create a tabbed pane to hold the files for clustering and
		// assembly separately.
		JTabbedPane tabPane = new JTabbedPane();
		// Create the necessary tabs in the tab pane
		if (clustering) {
			createClusteringFileEntries(tabPane);
		}
		// Create the assembly file entries
		createAssemblyFileEntries(tabPane);
		// Place the default path and the tab pane (that contains file inputs
		// for assembly and clustering into a sub-panel to ensure good layout
		JPanel subPanel = new JPanel(new BorderLayout(0, 3));
		subPanel.add(defaultPath, BorderLayout.NORTH);
		subPanel.add(tabPane, BorderLayout.CENTER);
		
		// Create the wizard-page-level informational message label.
		JLabel info = new JLabel(PAGE_INFO_MSG,
				Utilities.getIcon("images/32x32/Information.png"),
				JLabel.LEFT);
		// Finally create the top-level panel to contain an
		// informational label and the subPanel.
		JPanel panel = new JPanel(new BorderLayout(0, 0));
		panel.add(info, BorderLayout.NORTH);
		panel.add(subPanel, BorderLayout.CENTER);
		// Add the contents to this page
		add(panel, BorderLayout.CENTER);
	}
	
	/**
	 * Helper method to create the file entries associated with clustering.
	 * This method was introduced to streamline the code in the constructor.
	 * This method is called only once from the constructor to create the
	 * tab page with inputs to specify file names for the files generated
	 * after clustering.
	 * 
	 * @param parent The parent tab pane to which a tab containing various
	 * input entries is to be added. This parameter cannot be null.
	 */
	private void createClusteringFileEntries(JTabbedPane parent) {
		// Create the file inputs for MST and cluster file.
		JPanel mstFileInput = createFileInput(1, 
				"MST output file:", FILE_PATH_TOOL_TIP, false);
		JPanel clsFileInput = createFileInput(2, 
				"Clustering output file:", FILE_PATH_TOOL_TIP, false);
		// Place them in another panel to ensure good layout
		JPanel entryPanel = Utilities.createLabeledComponents(null, null, 0,
				true, mstFileInput, Box.createVerticalStrut(8), clsFileInput);
		entryPanel.setBorder(new EmptyBorder(5, 8, 5, 8));
		// Add the entry panel with various file inputs to the parent
		// tabbed panel.
		parent.addTab("Clustering", 
				Utilities.getIcon("images/16x16/Cluster.png"), 
				entryPanel);
	}
	
	/**
	 * Helper method to create the file entries associated with assembly.
	 * This method was introduced to streamline the code in the constructor.
	 * This method is called only once from the constructor to create the
	 * tab page with inputs to specify file names for the files generated
	 * after assembly.
	 * 
	 * @param parent The parent tab pane to which a tab containing various
	 * input entries is to be added. This parameter cannot be null.
	 */
	private void createAssemblyFileEntries(JTabbedPane parent) {
		// Create the file inputs for MST and cluster file.
		JPanel contingFileInput = createFileInput(3, 
				"", FILE_PATH_TOOL_TIP, false);
		contigOutputLabel = (JLabel) contingFileInput.getComponent(0);
		JPanel singleFileInput = createFileInput(4, 
				"Singletons output file:", FILE_PATH_TOOL_TIP, false);
		JPanel miscFileInput = createFileInput(5, 
				"Statistics output file:", FILE_PATH_TOOL_TIP, false);
		// Place them in another panel to ensure good layout
		JPanel entryPanel = Utilities.createLabeledComponents(null, null, 0,
				true, contingFileInput, Box.createVerticalStrut(8), 
				singleFileInput, Box.createVerticalStrut(8), miscFileInput);
		entryPanel.setBorder(new EmptyBorder(5, 8, 5, 8));
		// Add the entry panel with various file inputs to the parent
		// tabbed panel.
		parent.addTab("Assembly", 
				Utilities.getIcon("images/16x16/EAST.png"), 
				entryPanel);
	}

	/**
	 * Helper method to create an entry panel where the user can
	 * select a directory or file name. The entry panel contains
	 * the following GUI elements:
	 * 
	 * <ul>
	 * <li>A brief label/message at the top.</li>
	 * <li>Below the label is a text field where the user can
	 * enter a file name or directory.</li>
	 * <li>A browse button to the right of the above text field
	 * that the user can click to select a path or file interactively.</li>
	 * </ul>
	 * 
	 * @param entryIndex The index of the text field in the 
	 * {@link #outFileNames} array to be populated/used by this method.
	 * 
	 * @param titleText A brief text that is displayed at the top of
	 * the input field to provide the user with some information about
	 * the purpose of the input.
	 * 
	 * @param toolTipText A generic tool tip to provide some additional
	 * information to the user.
	 * 
	 * @param labelButton A flag to indicate if the browse button
	 * should also include the "Browse" text.
	 * 
	 * @return A panel containing the various entities of an etry panel
	 * suitably organized.
	 */
	private JPanel createFileInput(final int entryIndex,
			final String titleText,
			final String toolTipText,
			final boolean labelButton) {
		// Create the text field at the given entry index.
		outFileNames[entryIndex] = new JTextField();
		outFileNames[entryIndex].setToolTipText(toolTipText);
		// Create a browse button with an optional label
		final String IconPath = "images/16x16/Browse.png";
		final String BtnText  = (labelButton ? "Browse" : null);
		final String ActCmd   = "" + entryIndex;
		JButton browse = Utilities.createButton(IconPath, BtnText, 
				ActCmd, this, BROWSE_TOOL_TIP, true);
		// Create the label to be displayed on top of this input field
		JLabel label = new JLabel(titleText);
		JPanel entryPanel = new JPanel(new BorderLayout(5, 0));
		entryPanel.add(label, BorderLayout.NORTH);
		entryPanel.add(outFileNames[entryIndex], BorderLayout.CENTER);
		entryPanel.add(browse, BorderLayout.EAST);
		return entryPanel;
	}

	/**
	 * Obtain the absolute path to the file specified by the user
	 * for a given entry.
	 * 
	 * @param entryIndex The index of the entry whose file path is
	 * to be returned. The entry index value corresponds to:
	 * 
	 * <ol>
	 * 	<li>MST output file name.</li>
	 *  <li>Cluster output file name.</li>
	 *  <li>Contigs/consensus output file name.</li>
	 *  <li>Singleton ESTs output file name.</li>
	 *  <li>Statistics from assembly.</li>
	 * </ol>
	 * 
	 * @return The absolute path to the file (if applicable) or null
	 * if a value is not applicable.
	 */
	public String getFilePath(int entryIndex) {
		final String defDir = outFileNames[0].getText();
		String path   = null;
		if (outFileNames[entryIndex] != null) {
			String entry = outFileNames[entryIndex].getText();
			if (!entry.startsWith(defDir)) {
				entry = defDir + File.separator + entry;
				File tmpFile = new File(entry);
				path = tmpFile.getAbsolutePath();
			}
		}
		return path;
	}
	
	@Override
	public void actionPerformed(ActionEvent event) {
		// Check to ensure that this action handler is called only for
		// browse buttons
		if ("012345".indexOf(event.getActionCommand()) == -1) {
			// This is not for one of the file input fields
			return;
		}
		// Get the input field in question.
		int index = Integer.parseInt(event.getActionCommand());
		// Let the user interactively choose the directory/file
		JFileChooser jfc = new JFileChooser();
		if (index == 0) {
			jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		}
		jfc.setDialogTitle("Choose target file or directory");
		jfc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
		if (jfc.showDialog(this, "Use Directory") == JFileChooser.APPROVE_OPTION) {
			// Copy the chosen directory to the mst file entry
			File path = jfc.getSelectedFile();
			// Handle the case of default vs. non-default paths
			if (index == 0) {
				// This is the default path.
				outFileNames[index].setText(path.getAbsolutePath());
				// Check to ensure that the default path is a valid directory.
				validateDefaultDir();
			} else {
				// For non-default path, strip out the default path prefix
				// if the default paths match up.
				String defaultPath = outFileNames[0].getText();
				if (defaultPath.equals(path.getAbsolutePath())) {
					outFileNames[index].setText(path.getName());
				} else {
					outFileNames[index].setText(path.getAbsolutePath());
				}
			}
		}
	}

	/**
	 * Helper method to check if the default directory (in {@link #outFileNames}[0])
	 * specified by the user is valid.
	 * 
	 * This method is called whenever a user selects a path or just before
	 * the wizard attempts to move to the next page. This method is used
	 * to validate that the default directory specified by the user is valid.
	 *  
	 * @return This method return true if the default directory is valid (either
	 * it exists or it can be created) and the user has read/write privileges on it. 
	 */
	private boolean validateDefaultDir() {
		// Extract default path from input text field.
		final String dirPath = outFileNames[0].getText().trim();
		// Is the default path empty. It is ok for it to be empty
		if (dirPath.length() == 0) {
			return true;
		}
		// Ensure it is a valid directory.
		File defDir = new File(outFileNames[0].getText().trim());
		if (defDir.isDirectory() && defDir.canRead() && defDir.canWrite()) {
			// OK. It is a directory. That is good no further checks needed.
			return true;
		}
		if (!defDir.exists())  {
			// OK, so the directory does not exist. However, check to 
			// ensure that it can be created.
			if (defDir.mkdir() && defDir.delete()) {
				// This is a valid directory entry that can be created.
				return true;
			}
		}
		// OK, the either the specified default path is not a valid
		// directory or we could not create it. Let the user know about it.
		final String htmlPath = Utilities.wrapStringToHTML(dirPath, 50);
		final String msg = String.format(INVALID_DEFAULT_DIRECTORY, htmlPath);
		JOptionPane.showMessageDialog(this, msg, 
				"Invalid default directory", JOptionPane.ERROR_MESSAGE);
		return false;
	}

	/**
	 * Helper method to check if the file name specified in a given entry
	 * is valid.
	 * 
	 * This method is called from the {@link #pageChanging(WizardDialog, int, int)}
	 * method to ensure that a given file name is valid. The validation rules
	 * applied by this method are:
	 * 
	 * <ol>
	 * <li>If the file entry for the given entry index is null, this
	 * method returns immediately with true</li>
	 * <li>If the file exists, then this method informs the user and
	 * confirms if the user want's to overwrite the existing file. If the 
	 * the user does not want to overwrite this method returns false.</li>
	 * 
	 * </ol>
	 *  
	 * @return This method return true if the given file entry is valid. Otherwise
	 * this method returns false. 
	 */
	private boolean validateFileEntry(final int entryIndex) {
		if (outFileNames[entryIndex] == null) {
			return true;
		}
		// Extract default path from input text field for further use
		// final File dirPath = new File(outFileNames[0].getText());
		// Next get the path specified by the user for our use.
		File tmpEntry = new File(outFileNames[entryIndex].getText());
		if (tmpEntry.exists()) {
			if (!tmpEntry.canWrite()) {
				// The file is not writeable. Let the user know it.
				final String msg = String.format(FILE_READ_ONLY_MSG, tmpEntry.getAbsolutePath());
				JOptionPane.showMessageDialog(this, msg, 
						"Read Only File", JOptionPane.ERROR_MESSAGE);
				return false;

			}
			// File already exists. Report warning to the user.
			final String msg = String.format(FILE_ALREADY_EXISTS, outFileNames[entryIndex]);
			if (JOptionPane.showConfirmDialog(this, msg, "File already exists", 
					JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == JOptionPane.NO_OPTION) {
				// The user does not want to overwrite the file.
				return false;
			}
		} else {  // File does not exist
			// Check to ensure that the parent directory exists and is valid.
			File parDir = tmpEntry.getParentFile();
			if (parDir != null) {
				// This is a directory that is not yet validated.
				if (!parDir.exists() || !parDir.canRead() || !parDir.canWrite()) {
					// Either the parent directory does not exist or does not have
					// permissions. Show an error
					final String msg = String.format(INVALID_FILE_DIRECTORY, tmpEntry.getName(), parDir.getAbsolutePath());
					JOptionPane.showMessageDialog(this, msg, 
							"Invalid directory", JOptionPane.ERROR_MESSAGE);
					return false;
				}
			}
		}
		// Check to ensure this file name does not collide with
		// any previous files.
		final String[] Usage = {"Def. Dir", "MST File", "Cluster File", "Consensus File", 
				"Singleton File", "Statistics File"};
		for(int i = 1; (i < entryIndex); i++) {
			final File prevEntry = new File(outFileNames[i].getText());
			if (prevEntry.equals(tmpEntry)) {
				// Duplicate file found
				final String msg = String.format(DUPLICATE_FILE_ENTRY,
						tmpEntry.getAbsolutePath(), Usage[i], Usage[entryIndex]);
				JOptionPane.showMessageDialog(this, msg, 
						"Duplicate File", JOptionPane.ERROR_MESSAGE);
				return false;
			}
		}
		// Everything went fine.
		return true;
	}

	/**
	 * Method to fill-in default file names and path when this page is
	 * displayed.
	 * 
	 * This method is called just before this page is to be displayed.
	 * This page essentially updates the data being displayed in
	 * the GUI fields as a convenience for the user.
	 * 
	 */
	@Override
	public void pageChanged(WizardDialog dialog, int currPage, int prevPage) {
		// Get the base data set to suggest file names
		DataSet ds = wizard.getDataSet();
		if ((ds == null) || (ds.getPath() == null)){
			return;
		}
		// Setup default directory and file names as default.
		File srcFile     = new File(ds.getPath());
		String parentDir = srcFile.getParent();
		if (parentDir == null) {
			parentDir = "";
		}
		// Add a job# to the parent directory to organize files better
		final int jobCount = Workspace.get().getJobList().getJobs().size();
		parentDir += File.separator + "job" + jobCount;
		// Setup default path based on path of the data set
		outFileNames[0].setText(parentDir);
		// Extract the source file name from the data set. For example if
		// data set is "lab_rat1.fasta" we retain just "lab_rat1" in baseFileName 
		String baseFileName = srcFile.getName();
		final int dotPos    = baseFileName.lastIndexOf('.');
		if (dotPos > 1) {
			baseFileName = baseFileName.substring(0, dotPos);
		}
		// Setup file names for various output files based on default directory
		final String outFileFormat  = wizard.getContigOutputFormat().toString();
		// Update label for the contig output file to provide additional information.
		this.contigOutputLabel.setText(outFileFormat + " contig/consensus output file:");
		final String[] NameSuffixes = {null, ".mst", ".cls", 
				"_east_contigs." + outFileFormat.toLowerCase(), 
				"_east_singletons.txt", "_east_stats.txt"};
		for(int i = 1; (i < outFileNames.length); i++) {
			if (outFileNames[i] != null) {
				outFileNames[i].setText(baseFileName + NameSuffixes[i]);
			}
		}
	}
	
	/**
	 * Check to ensure paths for various files are valid and the files don't exist.
	 * 
	 * This method is invoked when the user clicks the "Next>" button. This
	 * method overrides the default implementation in the base class and
	 * ensures that the user has supplied all the file names and the
	 * files don't exist.
	 */
	@Override
	public boolean pageChanging(WizardDialog dialog, int currPage, int nextPage) {
		if (nextPage < currPage) {
			// The user want's to go back. That's OK.
			return true;
		}
		// Check to ensure that the default directory (if specified) is valid.
		if (!validateDefaultDir()) {
			// The default directory is invalid. The helper method reported
			// the issue to the user. The wizard cannot proceed.
			return false;
		}
		// Ensure the file names for the various output files are valid and usable.
		for(int i = 1; (i < outFileNames.length); i++) {
			if (!validateFileEntry(i)) {
				// Invalid entry. User has been informed 
				return false;
				
			}
		}
		// It is fine to proceed to the next page.
		return true;
	}
	
	/**
	 * Flag to indicate if the mode in which the wizard (owning this page) is
	 * operating under. If this flag is true, then this wizard is to perform
	 * clustering+assembly (in which two sets of output files are needed).
	 * If this flag is false then this wizard is performing just assembly (and
	 * only one set of output file paths are needed).
	 */
	// private final boolean alsoCluster;
	
	/**
	 * An array of output file names that are edited by the user. The
	 * file names in this array are stored in the following order:
	 * 
	 * <ol start="0">
	 *  <li>Default directory.</li>
	 * 	<li>MST output file name.</li>
	 *  <li>Cluster output file name.</li>
	 *  <li>Contigs/consensus output file name.</li>
	 *  <li>Singleton ESTs output file name.</li>
	 *  <li>Statistics from assembly.</li>
	 * </ol>
	 */
	private JTextField outFileNames[] = new JTextField[6];
		
	/**
	 * A reference to the wizard dialog that logically owns this
	 * page. This reference is used to enable and disable 
	 * buttons on this wizard appropriately.
	 */
	private final EASTJobWizard wizard;
	
	/**
	 * A generic informational message that is displayed at the
	 * top of this wizard page providing a brief overview of the
	 * purpose of this page.
	 */
	private static final String PAGE_INFO_MSG = 
		"<html>" +
		"Configure various output files (on this machine) with either<br/>" +
		"relative (based on <i>default</i> path) or absolute path." +
		"</html>";

	/**
	 * A simple text that is displayed to indicate the location where the
	 * user must enter the default file path. Maybe this message can become
	 * a bit more verbose if space permits.
	 */
	private static final String DEFAULT_PATH_INFO =
		"<html>Enter default path for files below:</html>";
		
	/**
	 * A generic informational message that displayed as the tool tip
	 * for the default path entry in this wizard page.
	 */
	private static final String DEFAULT_PATH_TOOL_TIP = 
		"<html>" +
		"The default path where various output files are to be stored.<br/>" +
		"The path may either be typed or selected using the adjacent<br/>" +
		"browse button. This path will be used for storing files (below)<br/>"+
		"that do not have an absolute path specified.<br/>" +
		"<b>Tip:</b>Storing related files in a single folder eases<br>" +
		"information management." +
		"</html>";

	/**
	 * A generic tool tip string that is associated with the various
	 * text fields where the user may type in a file name.
	 */
	private static final String FILE_PATH_TOOL_TIP =
		"<html>Type in a file name with relative (from <i>default</i> path<br/>" +
		"above) or absolute path. Optionally, the file name or path can be<br/>" +
		"set using the adjacent browse button.</html>";

	/**
	 * A generic error and troubleshooting message reporting issues with
	 * the default directory. This message is formatted via {@link String#format(String, Object...)}
	 * method (by the {@link #validateDefaultDir()} method) prior to display.
	 */
	private static final String INVALID_DEFAULT_DIRECTORY =
		"<html>The following directory you have specfied is <b>invalid</b>:<br/>" +
		"<i>%s</i><br/><br/>" +
		"Until this issue is resolved the wizard cannot proceed further.<br/><br/>" +
		"Troubleshooting tips:<br/>" +
		"&nbsp; &#149; Check to verify the path does not refer to a file<br/>" +
		"&nbsp; &#149; Verify the parent path already exists<br/>" +
		"&nbsp; &#149; Ensure necessary create/read/write privileges<br/>" +
		"</html>";
	
	/**
	 * A generic confirmation message reporting reuse of existing file to the user.
	 * This message is formatted via {@link String#format(String, Object...)}
	 * method (by the {@link #validateFileEntry(int)} method) prior to display.
	 */
	private static final String FILE_ALREADY_EXISTS =
		"<html>The following file you have specfied already exists:<br/>" +
		"<i>%s</i><br/><br/>" +
		"Continue by overwriting this file?" +
		"</html>";
	
	/**
	 * A generic error message reporting use of a read-only file to the user.
	 * This message is formatted via {@link String#format(String, Object...)}
	 * method (by the {@link #validateFileEntry(int)} method) prior to display.
	 */
	private static final String FILE_READ_ONLY_MSG =
		"<html>The following file you have specfied is <b>not writable</b>:<br/>" +
		"<i>%s</i><br/><br/>" +
		"Either the permissions on this file need to be adjusted <br/>" +
		"or a different file needs to be specified." +
		"</html>";
	
	/**
	 * A generic confirmation message used to report that a file specified is
	 * associated with an invalid directory.
	 * This message is formatted via {@link String#format(String, Object...)}
	 * method (by the {@link #validateFileEntry(int)} method) prior to display.
	 */
	private static final String INVALID_FILE_DIRECTORY =
		"<html>The directory/folder for the following file is <b>invalid</b>:<br/>" +
		"&nbsp; &nbsp; <b>File:</b><i>%s</i><br/>" +
		"&nbsp; &nbsp; <b>Directory:</b><i>%s</i><br/><br/>" +
		"Until this issue is resolved the wizard cannot proceed further.<br/><br/>" +
		"Troubleshooting tips:<br/>" +
		"&nbsp; &#149; Verify the folder/directory already exists<br/>" +
		"&nbsp; &#149; Ensure necessary create/read/write privileges<br/>" +
		"</html>";
	
	/**
	 * A generic error message used to report that a file with same path
	 * has been specified twice.
	 * This message is formatted via {@link String#format(String, Object...)}
	 * method (by the {@link #validateFileEntry(int)} method) prior to display.
	 */
	private static final String DUPLICATE_FILE_ENTRY =
		"<html>The following file has been specified twice:<br/>" +
		"&nbsp; &nbsp; <b>File:</b><i>%s</i><br/><br/>" +
		"It has been reused for: <br/>" +
		"&nbsp; &nbsp; &#149; %s<br/>" +
		"&nbsp; &nbsp; &#149; %s<br/><br/>" +
		"Please ensure all output files are unique." +
		"</html>";
	
	/**
	 * This is a reference to the label that is used to provide indication
	 * to the user about the type of file in which contigs are to be 
	 * generated. This value is set by the {@link #createAssemblyFileEntries(JTabbedPane)}
	 * method and updated by the {@link #pageChanged(WizardDialog, int, int)}
	 * method.
	 */
	private JLabel contigOutputLabel;
	
	/**
	 * A generic tool tip string that is associated with the various
	 * browse buttons on this wizard page.
	 */
	private static final String BROWSE_TOOL_TIP =
		"Browse local file system to find a directory or file";
	
	/**
	 * The generated serialization UID (need to keep the compiler happy) 
	 */
	private static final long serialVersionUID = -4846250014027414335L;
}
