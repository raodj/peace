//--------------------------------------------------------------------
//
// This file is part of PEACE.
// 
// PEACE is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// PEACE is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with PEACE.  If not, see <http://www.gnu.org/licenses/>.
// 
// Miami University makes no representations or warranties about the
// suitability of the software, either express or implied, including
// but not limited to the implied warranties of merchantability,
// fitness for a particular purpose, or non-infringement.  Miami
// University shall not be liable for any damages suffered by licensee
// as a result of using, result of using, modifying or distributing
// this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of GNU General Public License (version 3).
//
// Authors:   Dhananjai M. Rao              raodm@muohio.edu
//
//---------------------------------------------------------------------

package org.peace_tools.core.job.east;

import java.awt.Color;
import java.util.ArrayList;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;

import org.peace_tools.core.MainFrame;
import org.peace_tools.core.SummaryWriter;
import org.peace_tools.core.job.ServerPanel;
import org.peace_tools.generic.Utilities;
import org.peace_tools.generic.WizardDialog;
import org.peace_tools.workspace.ClusteringJob;
import org.peace_tools.workspace.DataSet;
import org.peace_tools.workspace.DataSet.DataFileType;
import org.peace_tools.workspace.EASTJob;
import org.peace_tools.workspace.FWAnalyzer;
import org.peace_tools.workspace.FWAnalyzer.FWAnalyzerType;
import org.peace_tools.workspace.FileEntry;
import org.peace_tools.workspace.FileEntry.FileEntryType;
import org.peace_tools.workspace.DOMHelper;
import org.peace_tools.workspace.Filter;
import org.peace_tools.workspace.GeneratedFileList;
import org.peace_tools.workspace.Heuristic;
import org.peace_tools.workspace.Job;
import org.peace_tools.workspace.JobList;
import org.peace_tools.workspace.JobSummary;
import org.peace_tools.workspace.Param;
import org.peace_tools.workspace.Server;
import org.peace_tools.workspace.Workspace;

/**
 * This class serves as the top-level class for creating a new 
 * EAST job. This wizard can create an EAST job in one of the 
 * following two manners:
 * 
 * <ul>
 * 
 * <li>In the simple case it permits the user to select an existing
 * clustering solution (generated earlier via a PEACE job) from the
 * work space and use it for assembly.</li>
 * 
 * <li>It permits the user to create two jobs, the first one is a 
 * clustering job which is followed by a second EAST job that performs
 * assembly. Note that in the second case, the default parameters that
 * provide best solution for use with EAST are automatically assumed.
 * If a user want's to customize clustering parameters, then the user
 * needs to run a separate clustering job followed by an assembly job.
 * </li>
 * 
 * </ul>
 * 
 * <p>An EAST job is used to assemble cDNA fragments into contigs/genes.
 * In this specific case we use the Expression Fragment Assembly from
 * Spanning Trees (EAST) assembler developed at Miami.
 * EAST uses the Minimum Spanning Tree data structure generated by PEACE
 * clustering engine for accelerating the assembly process.
 * EAST representing the cDNA input fragments as a MST, quickly 
 * assigns edge weights with a new distance heuristic for detecting edge
 * overlap, and calculates a revised minimum spanning tree. The revised
 * MST enables to quick traversal to accurately order the input cDNA sets, 
 * filter out extraneous ESTs, correct errors and infer the actual 
 * transcript sequence from which the set was generated.</p> 
 * 
 * This top-level class merely creates the various pages and adds them
 * to this wizard. Each page performs a specific task required to 
 * create/configure a complete job(s) to be run on a server.
 *  
 * <p><b>Note:</b> In order to create a job, there must be at least one
 * data set and one server entry in the work space.</p> 
 */
public class EASTJobWizard extends WizardDialog {
	/**
	 * Helper method to validate necessary preconditions prior to creating the
	 * job wizard.
	 * 
	 * This is a helper method that is used to ensure that:
	 * 
	 * <ol>
	 * <li>That there is at least one data set in the workspace.</li>
	 * <li>That there is at least one valid server entry that can be used for
	 * assembly.</li>
	 * </ol>
	 * 
	 * @param title The title to be set for the wizard window being created. 
	 * This parameter cannot be null.
	 * 
	 * @param parent The parent window for the wizard dialog box. This parameter
	 * cannot be null.
	 * 
	 * @param alsoCluster If this flag is true, then the wizard is expected to
	 * perform clustering and assembly. If the flag is false, then this wizard
	 * is launched just for an assembly job.
	 * 
	 * @return If the workspace has the necessary/valid data sets and server
	 * entries, then this method instantiates a valid wizard and returns
	 * the newly created wizard for further use. 
	 */
	public static EASTJobWizard create(String title, MainFrame parent, 
			boolean alsoCluster) {
		// Check to ensure we have a valid data set and/or an MST file 
		// for clustering and/or assembly. if we don't find a valid
		// entry then the following message is set. If a valid entry
		// was found then this message is left null.
		String[] msg = null;
		if (alsoCluster) {
			// We need just a good data set for a clustering+assembly job
			msg = EASTJobWizard.NO_DATASET_MSG; // Set invalid condition
			final ArrayList<DataSet> dataSets = Workspace.get().getDataSets();
			// Check to ensure we have at least one good data set entry
			for(DataSet ds: dataSets) {
				if (ds.isGood() && (ds.getFileType().equals(DataFileType.FASTA))) {
					msg = null; // We got a good data set
					break;      // no further checks needed.
				}
			}
		} else {
			// We need a MST for an assembly-only job.
			// Did not find a valid mst entry so far.
			msg = EASTJobWizard.NO_MST_MSG;
			for(DataSet ds: Workspace.get().getDataSets()) {
				for(GeneratedFileList gfl: ds.getGflList()) {
					FileEntry mst = gfl.findEntry(FileEntryType.MST);
					if ((mst != null) && (mst.isGood())) {
						msg = null;
						break;
					}
				}
			}
		}
		// Next check to ensure that we have a server that
		// can do clustering and/or assembly.
		if ((msg == null) && 
			(ServerPanel.getServerList(alsoCluster, true, new JComboBox()) == 0)) {
			// We have valid data set/mst but no valid server
			msg = EASTJobWizard.NO_SERVER_MSG;
		}
		// Display error message is set
		if (msg != null) {
			showMessage(parent, msg);
			return null;
		}
		// Return new wizard only if msg is null indicating no errors.
		return new EASTJobWizard(title, parent, alsoCluster);
	}
	
	/**
	 * Helper method to show a formatted message to the user.
	 * 
	 * This method is invoked from the the {@link EASTJobWizard#create(String, MainFrame, boolean)}
	 * to display a properly formatted message to the user.
	 * 
	 * @param parent The parent window to be used for displaying the 
	 * message in a modal dialog box.
	 * 
	 * @param messages This method is always invoked with an array of three
	 * entries. The entries are in the following order:
	 * <ol>
	 *   <li>First entry is a informational message</li>
	 *   <li>The second entry reports an issue to the user.</li>
	 *   <li>The last entry provides suggestions to resolve the issue</li>
	 * </ol>
	 */
	private static void showMessage(MainFrame parent, String[] messages) {
		// The icon names corresponding to the three entries in messages 
		final String[] IconNames = {null, "Warning", "Help"};
		// The main panel that contains the labels being created in the
		// for-loop below
		JPanel msgPanel = new JPanel();
		msgPanel.setLayout(new BoxLayout(msgPanel, BoxLayout.PAGE_AXIS));
		// Create the labels to be displayed.
		for(int i = 0; (i < IconNames.length); i++) {
			// Create a icon if an image/fileName has been specified.
			ImageIcon icon = null;
			if (IconNames[i] != null) {
				icon = Utilities.getIcon("images/32x32/" + IconNames[i] + ".png");
			}
			// Create label with the part of the message
			final String htmlMsg = "<html>" + messages[i] + "</html>";
			JLabel infoMsg = new JLabel(htmlMsg, icon, JLabel.LEFT);
			// Add it to the main message panel.
			msgPanel.add(infoMsg);
			// Add a spacer to make things look decent.
			msgPanel.add(Box.createVerticalStrut(8));
		}
		// Display the message.
		JOptionPane.showMessageDialog(parent, msgPanel, 
				"Cannot launch wizard now", JOptionPane.INFORMATION_MESSAGE);
	}
	
	/**
	 * The constructor for the job wizard.
	 * 
	 * The constructor lays out the wizard and creates all the
	 * wizard pages. The wizard pages are created as templates
	 * and get populated with the necessary information just before
	 * the pages get displayed to the user.
	 * 
	 * @param title The title to be set for the main wizard frame.
	 * 
	 * @param parent The main frame that logically owns this wizard.
	 * 
	 * @param alsoCluster If this flag is true, then the wizard is expected to
	 * perform clustering and assembly. If the flag is false, then this wizard
	 * is launched just for an assembly job.
	 * 
	 * @see EASTJobWizard#create(String, MainFrame, boolean)
	 */
	private EASTJobWizard(String title, MainFrame parent, boolean alsoCluster) {
		super(parent);
		this.mainFrame = parent;
		setTitle(title);
		setResizable(false);
		// Set up the title image we want to use.
		setTitleBackground("images/peace_wizard_header.png", Color.white);
		// Set up the column image we want to use.
		setSequenceBackground("images/peace_wizard_column.png");
		// First setup the overview page.
		owp = new OverviewPage(this, alsoCluster);
		addPage(owp);
		// Next add the page to select the MST file & data set to be used
		// for assembly.
		dssp = new DataSetSelectionPage(this, alsoCluster);
		addPage(dssp);
		// Next add the page to select the server for clustering for
		// clustering+assembly 
		if (alsoCluster) {
			clustSWP = new ServerWizardPage(this, alsoCluster, null);
			addPage(clustSWP);
		} else {
			clustSWP = null;
		}
		// Next add the page to select the server for assembly.
		assemblySWP = new ServerWizardPage(this, false, clustSWP);
		addPage(assemblySWP);
		// The EAST basic parameters wizard page follows
		ebpwp = new EASTBasicParamsPage(this);
		addPage(ebpwp);
		// Create the wizard page where the user can specify the 
		// path for various output files to be generated by the job(s)
		ofwp = new OutputFilesPage(this, alsoCluster);
		addPage(ofwp);
		// Create the job summary page with summary tabs for
		// assembly job and clustering job.
		vwp = new VerificationPage(this, alsoCluster);
		addPage(vwp);
		
		// Create the assembly job submission page with suitable titles
		if (alsoCluster) {
			assemblyJSWP = new SubmitJobWizardPage(this, false, alsoCluster,
					"Create Assembly Job", 
					"Create (not start) an assembly job on server");
		} else {
			assemblyJSWP = new SubmitJobWizardPage(this, false, alsoCluster,
					"Start Assembly Job", 
					"Create and start an assembly job on server");			
		}
		addPage(assemblyJSWP);
		
		// Create the clustering job submission page (if needed)
		if (alsoCluster) {
			clustJSWP = new SubmitJobWizardPage(this, true, alsoCluster,
					"Start Clustering Job", 
					"Create and start a clustering job on server");
			addPage(clustJSWP);
		} else {
			clustJSWP = null;
		}
	}

	/**
	 * Helper method invoked when user clicks cancel button.
	 * 
	 * This is a helper method that is overridden in this class.
	 * This method is invoked when the user clicks the cancel
	 * button in the wizard. This method is used to display a 
	 * confirmation dialog to ensure that the user really wants to
	 * exit out of the wizard.
	 * 
	 * @return This method returns true if the user wants to quit
	 * out of the wizard dialog.
	 */
	@Override
	protected boolean cancel() {
		// Check if user really want's to quit.
		int result = JOptionPane.showConfirmDialog(this,
				"Are you sure you want to exit from this wizard?",
				"Confirm", JOptionPane.YES_NO_OPTION);
		if (result == JOptionPane.NO_OPTION) {
			// The user does not want to quit.
			return false;
		}
		// Yes, the user wants to quit. Ensure no threads are left.
		return super.cancel();
	}
	
	/**
	 * This method overrides the final notification method in this
	 * wizard. Currently this method has no specific task to 
	 * perform but is present as a place holder for future 
	 * enhancements. 
	 */
	@Override
	public void done(boolean success) {
		if (!success) {
			return;
		}
	}
	
	/**
	 * Helper method to create a temporary or permanent clustering or
	 * assembly job.
	 * 
	 * This is an internal helper method that is used by this wizard
	 * to display summary information and create a job entry to be
	 * added to the workspace.
	 * 
	 * @param reserveJobID If this flag is true, then this method
	 * requests a new job ID to be created and reserved. Otherwise
	 * the job ID is set to the string "TBD".
	 * 
	 * @param assembly If this flag is true, then this method creates
	 * a job entry for assembly via EAST. If this flag is false
	 * this method creates a job entry for a parallel clustering job
	 * via PEACE.
	 * 
	 * @return A job entry for a job corresponding to a clustering or
	 * assembly job.
	 */
	protected Job createJobEntry(boolean assembly, boolean reserveJobID) { 
		final int jobIndex = (assembly ? 1 : 0);
		if (job[jobIndex] != null) {
			return job[jobIndex];
		}

		// Get parameters for assembly job
		ArrayList<Param> paramList = (assembly ? ebpwp.getParamList() :
			new ArrayList<Param>());
		// Get the server information provided by the user
		ServerWizardPage srvrPage = (assembly ? assemblySWP : clustSWP);
		Server server = srvrPage.getServerInfoPanel().getSelectedServer(); 
		// Get the platform-configuration for this job
		final int platformInfo[] = srvrPage.getServerInfoPanel().getPlatformConfiguration();
		// Compute the total memory to be used for the job by:
		// #Nodes * #CPUs/Node * #Memory/CPU
		final int totalMemory = platformInfo[0] * platformInfo[1] * platformInfo[2];
		// Setup job description
		final String rawJobDesc = (assembly ? owp.getDescription() : DEFAULT_DESCRIPTION);
		final String jobDesc    = DOMHelper.xmlEncode(rawJobDesc);
		// Get an unique ID for this job if requested
		JobList jobList = Workspace.get().getJobList();
		final String jobID = (reserveJobID ? jobList.reserveJobID() : "TBD");
		// Create the new job entry (the following variable is set by the
		// if-else block below)
		Job tmpJob = null;
		if (!assembly) {
			// Create default analyzer to be used for comparing cDNA fragments
			// for constructing MST.
			FWAnalyzer analyzer = new FWAnalyzer(FWAnalyzerType.TWOPASSD2, true, 100, 6, "heap", 128);
			// Create entries for default set of filters used by PEACE
			ArrayList<Filter> filtList = (assembly ? null : ClusteringJob.createDefaultFilters());
			// Create empty heuristics as we use an adaptive two-pass-d2
			// analyzer that uses its own custom heuristics and does not
			// need any heuristics specified on the command line.
			ArrayList<Heuristic> heurList = (assembly ? null : new ArrayList<Heuristic>());
			// Create clustering job
			ClusteringJob clsJob = 
				new ClusteringJob(
					jobID, jobDesc, server.getID(),
					null,             // Path on server for job-files.
					platformInfo[0],  // number of nodes, 
					platformInfo[1],  // CPUs per node, 
					totalMemory,      // memory, 
					platformInfo[3],  // runTime
					analyzer,
					1,                // Threshold for clustering
					heurList,         // heuristic list
					filtList,         // Filter list
					paramList);       // Empty parameters for starters
			// Ensure parameters are populated
			GeneratedFileList gfl = createGFL(false, reserveJobID, clsJob);
			clsJob.setupParameters(getDataSet(), gfl, true);
			// Update the dependent job ID & summary on the EAST job.
			if (job[1] != null) {
				job[1].setPreviousJobID(jobID);
				// Update status of any job summaries in the data sets
				GeneratedFileList eastGfl = Workspace.get().getGFL(job[1].getJobID());
				if (eastGfl != null) {
					eastGfl.getJobSummary().setPreviousJobID(jobID);
				}
			}
			// Setup the common job variable for further use
			tmpJob = clsJob;
		} else {
			// Assembly job
			EASTJob eastJob = new EASTJob(jobID, jobDesc, server.getID(), 
					null,             // Path on server for job-files.
					totalMemory,      // memory, 
					platformInfo[3],  // runTime
					paramList);       // Cmd-line parameters
			// Add input & output files as parameters as well. For this we
			// need to figure out the MST file entry depending on whether
			// this is a clustering+assembly or just assembly job.
			FileEntry mstFE = getMSTFile();
			if (mstFE == null) {
				// This is a clustering+assembly job.
				mstFE = new FileEntry("TBD", FileEntryType.MST, 
						DataFileType.TXT, ofwp.getFilePath(1), DEFAULT_DESCRIPTION);
			}
			GeneratedFileList gfl = createGFL(true, reserveJobID, eastJob);
			eastJob.addParameters(getDataSet(), mstFE, null, gfl);
			// Setup the common job variable for further use
			tmpJob = eastJob;
		}
		assert ( tmpJob != null );
		// Save job entry for future reference only if we have reserved
		// a job ID.
		if (reserveJobID) {
			job[jobIndex] = tmpJob;
		}
		// Return the newly constructed job object back to the caller
		return tmpJob;
	}

	/**
	 * Access method to obtain the list of files to be generated by
	 * this method. This method is typically used by the
	 * SubmitClusteringJobWizard class.
	 * 
	 * @return The list of files generated by the job created by
	 * this wizard.
	 */
	protected GeneratedFileList createGFL(boolean assemblyJob, 
			boolean reserveID, Job job) {
		// Build a job summary.
		JobSummary summary = new JobSummary(job);
		Workspace workspace = Workspace.get();
		GeneratedFileList gfl = new GeneratedFileList(summary);

		if (!assemblyJob) {
			final String mstID = (reserveID ? workspace.reserveID() : "TBD");
			FileEntry mstFE = new FileEntry(mstID, FileEntryType.MST, 
					DataFileType.TXT, ofwp.getFilePath(1), DEFAULT_DESCRIPTION);
			// Append information about cluster file by creating a 
			// temporary dummy entry.
			final String clsID = (reserveID ? workspace.reserveID() : "TBD");
			FileEntry clsFE = new FileEntry(clsID, FileEntryType.CLS,
					DataFileType.TXT, ofwp.getFilePath(2), DEFAULT_DESCRIPTION);
			// Add jobs to the generated file list
			gfl.add(mstFE);
			gfl.add(clsFE);
		} else {
			final String description = owp.getDescription();
			final String contigID = (reserveID ? workspace.reserveID() : "TBD");
			FileEntry contigFE = new FileEntry(contigID, FileEntryType.ASM, 
					ebpwp.getContigOutputFormat(), ofwp.getFilePath(3), description);
			
			final String singID = (reserveID ? workspace.reserveID() : "TBD");
			FileEntry singFE = new FileEntry(singID, FileEntryType.SINGLETONS, 
					DataFileType.FASTA, ofwp.getFilePath(4), description);
			
			final String statsID = (reserveID ? workspace.reserveID() : "TBD");
			FileEntry statsFE = new FileEntry(statsID, FileEntryType.STATS, 
					DataFileType.TXT, ofwp.getFilePath(5), description);
			
			// Add jobs to the generated file list
			gfl.add(contigFE);
			gfl.add(singFE);
			gfl.add(statsFE);
		}
		return gfl;
	}
	

	/**
	 * Helper method to return the data set on which
	 * operations are being performed by this wizard.
	 * 
	 * This method is currently used by the 
	 * {@link OutputFilesPage#pageChanging(WizardDialog, int, int)}
	 * to suggest default path and file names to the user. This method
	 * returns the the data set entry (from which cDNA file names, MST
	 * file names etc. can be derived) on which operations are being 
	 * performed by this wizard.
	 * 
	 * @return The path to the main data set file on which the user is
	 * operating on. If a valid data set file is not yet available,
	 * then this method returns null.
	 */
	protected DataSet getDataSet() {
		DataSet dataSet      = null;
		Object currSelection = dssp.getSelection();
		if (currSelection instanceof DataSet) {
			dataSet = (DataSet) currSelection;
		} else if (currSelection instanceof FileEntry) {
			FileEntry mst = (FileEntry) currSelection;
			dataSet     = mst.getGFL().getDataSet();
		}
		return dataSet;
	}
	
	/**
	 * Obtain the output file type currently chosen by the user.
	 * 
	 * This method is used by the OutputFilesWizardPage to provide
	 * appropriate default extension to the default files suggested
	 * by the wizard.
	 * 
	 * @return The output file type currently chosen by this method.
	 */
	protected DataFileType getContigOutputFormat() {
		return ebpwp.getContigOutputFormat();
	}
	
	/**
	 * Helper method to create temporary classes and use them to generate
	 * summary information about a clustering job.
	 * 
	 * This method is invoked from the VerificationWizardPage when it is
	 * displayed to obtain a summary information about the clustering
	 * job to be created.
	 * 
	 * @param summary The summary writer that must be used to generate
	 * the summary information.
	 */
	protected void setClusteringJobSummary(SummaryWriter summary) {
		// Create summary information about the data set being clustered
		DataSet ds = getDataSet();
		ds.summarize(summary);
		
		// Create a dummy clustering job
		Job job = this.createJobEntry(false, false);
		// Let the job write out its summary
		job.summarize(summary);
		
		// Create the GFL for summarizing output files
		GeneratedFileList gfl = this.createGFL(false, false, job);
		// Let the GFL summarize output files
		gfl.summarize(summary);		
	}
	
	/**
	 * Helper method to create temporary classes and use them to generate
	 * assembly information about a clustering job.
	 * 
	 * This method is invoked from the VerificationWizardPage when it is
	 * displayed to obtain a summary information about the assembly
	 * job to be created.
	 * 
	 * @param sw The summary writer that must be used to generate
	 * the summary information.
	 */
	protected void setAssemblyJobSummary(SummaryWriter sw) {
		// If this is a direct assembly job then display information
		// about the MST being used first.
		if (clustSWP == null) {
			FileEntry mstEntry = (FileEntry) dssp.getSelection();
			mstEntry.summarize(sw);
			mstEntry.getGFL().getJobSummary().summarize(sw);
		}
		// Create summary information about the data set being assembled
		DataSet ds = getDataSet();
		ds.summarize(sw);

		// Create a dummy clustering job
		Job job = createJobEntry(true, false);
		// Let the job write out its summary
		job.summarize(sw);
		
		// Create the GFL for summarizing output files
		GeneratedFileList gfl = this.createGFL(true, false, job);
		// Let the GFL summarize output files
		gfl.summarize(sw);		
	}
	
	/**
	 * Helper method to return the MST file entry for assembly-only
	 * job.
	 * 
	 * This is a helper method that is used by 
	 * {@link SubmitJobWizardPage#getFilesToCopy()} to obtain the MST
	 * file entry (if any) to be copied to a server.
	 * 
	 * @return This method returns the file entry corresponding to the
	 * MST file to be copied to a server. If a file entry is not applicable
	 * this method returns null.
	 */
	protected FileEntry getMSTFile() {
		Object currSelection = dssp.getSelection();
		if (currSelection instanceof FileEntry) {
			FileEntry mst = (FileEntry) currSelection;
			return mst;
		}
		return null;
	}
	
	/**
	 * Helper method to obtain the Job entry for the EAST-job in the case
	 * of a clustering+assembly mode.
	 * 
	 * This is a helper method that is used by 
	 * {@link SubmitJobWizardPage#getEASTWorkDir()} to obtain the 
	 * working directory set for an EAST job that has already been
	 * submitted (but is not running). This information is used by
	 * the clustering job to start the EAST job once the clustering job
	 * successfully completes.
	 * 
	 * @return This method returns the working directory (on the remote server)
	 * where the files for an EAST-assembly job have been created.
	 */
	protected String getEASTWorkDir() {
		return job[1].getPath();
	}
	
	/**
	 * Obtain the instance of the main frame class that owns this wizard.
	 * 
	 * This method is currently used by the submit job wizard page 
	 * to create a job monitor once a job has been successfully
	 * submitted. 
	 * 
	 * @return The main frame that owns this wizard.
	 */
	protected MainFrame getMainFrame() {
		return mainFrame;
	}
	
	/**
	 * A simple wizard page that contains the overview message
	 * and a brief description of the job entered by the user.
	 */
	private final OverviewPage owp;
	
	/**
	 * The wizard page that contains the description
	 * of the data set selected for the job along with a brief
	 * job description.
	 */
	private final DataSetSelectionPage dssp;
	
	/**
	 * The wizard page contains the server and associated
	 * job configuration information for creating an
	 * clustering job.
	 */
	private final ServerWizardPage clustSWP;

	/**
	 * The wizard page contains the server and associated
	 * job configuration information for creating an
	 * assembly job.
	 */
	private final ServerWizardPage assemblySWP;

	/**
	 * The EAST basic parameters wizard page contains the core
	 * set of the EAST options that are exposed to the user for
	 * customization of EAST's operations.
	 */
	private final EASTBasicParamsPage ebpwp;

	/**
	 * The filter wizard page that contains information about the target
	 * path for the various output files to be generated by the job(s).
	 */
	private final OutputFilesPage ofwp;
	
	/**
	 * The wizard page that collects and displays summary information 
	 * about the various jobs being submitted by this wizard.
	 */
	private final VerificationPage vwp;
	
	/**
	 * The wizard page that is used to submit a clustering job on a 
	 * selected server. This object is created only when this wizard
	 * is run a assembly+clustering mode.
	 */
	private final SubmitJobWizardPage clustJSWP;

	/**
	 * The wizard page that is used to submit an assembly job on a 
	 * selected server. This object is always created to submit an
	 * EAST job on the selected server.
	 */
	private final SubmitJobWizardPage assemblyJSWP;

	/**
	 * The job entries that is finally created by this job wizard
	 * when the final wizard page is displayed. These entries are
	 * used by the final wizard pages to perform its operations.
	 * The first entry in this array corresponds to the clustering
	 * job (if any) while the second entry in this array corresponds
	 * to the assembly job. 
	 */
	private Job[] job = new Job[2];
	
	/**
	 * The main frame that logically owns this job. This value is
	 * used to create a job monitor if a job is successfully 
	 * submitted to run on a server.
	 */
	private final MainFrame mainFrame;
	
	/**
	 * A simple static message that is displayed to the user if
	 * a valid data set is not found in the workspace for a
	 * clustering + assembly job.  
	 */
	private static final String[] NO_DATASET_MSG = {
		"The cDNA/EST fragments (called a <i>dataset</i>) to be<br/>" +
		"clustered and assembled must be present in the workspace.",
		"<b>Currently, the workspace does not have a dataset with<br/>" +
		"a FASTA file (EAST can work only with FASTA files)</b>",
		"Add the cDNA data set to be clustered and assembled<br/>" +
		"to the workspace prior to launching this wizard.<br/>" +
		"You may add a new data set using the data set wizard."
	};

	/**
	 * A simple static message that is displayed to the user if
	 * a valid MST file is not found in the workspace for a
	 * assembly-only job.  
	 */
	private static final String[] NO_MST_MSG = {
		"In order to just assemble using EAST the cDNA/EST fragments in<br/>" +
		"a data set must have been clustered and a suitable Minimum<br/>" +
		"Spanning Tree (MST) file must be available.",
		"<b>Currently, this workspace does not have a MST file and the<br/>" +
		"wizard cannot be launched.</b>", 
		"&nbsp; &#149; Run a clustering job to create a MST file.<br/>" +
		"&nbsp; &#149; Use the 'Clustering And Assembly' wizard."
	};
	
	/**
	 * A simple static message that is displayed to the user if
	 * a valid MST file is not found in the workspace for a
	 * assembly-only job.  
	 */
	private static final String[] NO_SERVER_MSG = {
		"In order to run an assembly job a server in good operating<br/>" +
		"condition must be present in the workspace.",
		"<b>Could not find a valid server in good operating condition<br/>" +
		"that has both PEACE and EAST installed on it.</b>",
		"This issue can resolved either by:<br/>" +
		"&nbsp; &#149; Adding a new server entry using the server wizard<br/>" +
		"&nbsp; &#149; or by troubleshooting an existing server entry, if any<br/>" +
		"</ul>"
	};

	/**
	 * A simple string description that is associated with clustering job
	 * entries created by this wizard. This string merely provides the
	 * user with a future reference as to why/how a output file was created. 
	 */
	private final String DEFAULT_DESCRIPTION = 
		"Configuration/job entry automatically created for assembly+clustering " +
		"with default parameters (for analyzer, mst-builder, and cluster maker)";
	
	/**
	 * The generated serialization UID (need to keep the compiler happy) 
	 */
	private static final long serialVersionUID = -7424095401537856423L;
}
