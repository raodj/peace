//--------------------------------------------------------------------
//
// This file is part of PEACE.
// 
// PEACE is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// PEACE is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with PEACE.  If not, see <http://www.gnu.org/licenses/>.
// 
// Miami University makes no representations or warranties about the
// suitability of the software, either express or implied, including
// but not limited to the implied warranties of merchantability,
// fitness for a particular purpose, or non-infringement.  Miami
// University shall not be liable for any damages suffered by licensee
// as a result of using, result of using, modifying or distributing
// this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of GNU General Public License (version 3).
//
// Authors:   Dhananjai M. Rao          raodm@muohio.edu
//
//---------------------------------------------------------------------

package org.peace_tools.data;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

import org.peace_tools.generic.Pair;

/**
 * The top-level class that encapsulates all the pertinent information
 * regarding a MST data file. This class deserializes the information
 * in a MST data file generated by PEACE and stores it in memory.
 * The in-memory storage format for the core MST information is
 * achieved using an hierarchically nested set of MSTNode objects.
 * In addition, this class also maintains any generated information
 * that is placed in the file by PEACE. <br/><br/>
 * 
 * Note that the in-memory format represented by this class has been
 * primarily designed to provide more convenient access to the related
 * information and for display in a GUI. However, this class does
 * not directly perform any GUI related task. Instead, the GUI display
 * is organized using the MVC (Model-View-Controller) design pattern.
 * This class constitutes the "model" as in the MVC terminology.
 * 
 * <p><b>Note:</b>  In order to create a valid MST use the 
 * {@link #loadMST(File)} static method.</p>
 */
public class MST {
	/**
	 * The absolute path to the file name from where the MST data was
	 * originally loaded. 
	 * 
	 * @return The absolute path to the file that uniquely identifies
	 * the contents of the MST.
	 */
	public String getFileName() { return this.fileName; }
	
	/**
	 * Method to print the MST in a simple text-based format.
	 * 
	 * This method is primarily used for validating the MST data to
	 * ensure that the data was processed correctly.
	 * 
	 * @param out The output stream to which the MST data is to be 
	 * written.
	 */
	public void print(PrintStream out) {
		// First print the meta data out.
		for(Pair entry : metadata) {
			out.println(entry.getName() +
					(entry.getValue() != null ? ":" + entry.getValue() : ""));			
		}
		// Now recursively print the MST using helper method.
		root.print(out, root, "");
	}
	
	/**
	 * Obtain the root node of this MST.
	 * 
	 *  @return The root node of this MST data.
	 */
	public MSTNode getRoot() { return root; }
	
	/**
	 * Determine if all nodes in this MST have alignment information.
	 * 
	 * This method can be used to determine if all the nodes in this MST
	 * have alignment information. This information is handy to organize
	 * the fragments in the nodes in a more intuitive form to illustrate
	 * overlaps and for other visual analysis.
	 * 
	 * @return This method returns true if all the nodes in this MST have
	 * alignment information. Otherwise (even if one node does not have
	 * alignment information) then this method returns false.
	 * 
	 * @see OverlapModel
	 */
	public boolean hasAlignmentInfo() { return this.haveAlignmentInfo; }
	
	/**
	 * This method loads MST data into an in-memory format.
	 * 
	 * This method must be used to load MST data from a PEACE generated
	 * MST data file and deserialize the information into the in-memory
	 * format. The in-memory format provides an hierarchical organization
	 * that is a bit more streamlined and easier to display in the GUI.
	 * 
	 * @param mstFile The MST file (generated by PEACE) from where the
	 * data is to be loaded in the in-memory format.
	 * 
	 * @return On success this method returns a valid MST data structure
	 * loaded from the file.
	 * 
	 * @exception Exception This method throws an exception on errors.
	 */
	public static MST loadMST(File mstFile) throws Exception {
		FileInputStream fis = new FileInputStream(mstFile);
		return loadMST(mstFile.getAbsolutePath(), fis);
	}
	
	/**
	 * This method loads MST data into an in-memory format.
	 * 
	 * This method must be used to load MST data from a PEACE generated
	 * MST data file and deserialize the information into the in-memory
	 * format. The in-memory format provides an hierarchical organization
	 * that is a bit more streamlined and easier to display in the GUI.
	 * 
	 * @param fileName The absolute path to the file from where the data
	 * is being read.
	 * 
	 * @param is The input stream from where the data is to be read.
	 * 
	 * @return On success this method returns a valid MST data structure
	 * loaded from the file.
	 * 
	 * @exception Exception This method throws an exception on errors.
	 */
	public static MST loadMST(String fileName, InputStream is) throws Exception {
		// Wrap the MST file into a scanner to make line-by-line 
		// processing easier.
		Scanner input = new Scanner(is);
		// Create a temporary MST object to hold the data
		MST mst = new MST(fileName);
		// Use a hash map to maintain MSTs to look up index
		HashMap<Integer, MSTNode> nodeList = new HashMap<Integer, MSTNode>();
		// Put dummy parent entry for root
		nodeList.put(-1, null);
		// Process line-by-line from the MST file and track if all nodes have
		// alignment information (the following haveAlignInfo gets set to false
		// even if a single node does not have alignment information).
		boolean haveAlignInfo = true;
		while (input.hasNextLine()) {
			// Read the line in and ignore blank lines
			String line = input.nextLine().trim();
			if (line.length() < 1) {
				// Ignore blank lines.
				continue;
			}
			// The line is a meta data line if it starts with a '#'
			if (line.charAt(0) == '#') {
				// Process the meta data line.
				mst.metadata.add(makeMetadataEntry(line));
			} else {
				// Process the line with MST node information.
				haveAlignInfo &= makeMSTNode(nodeList, line);
				// Make a note of the root node 
				if (mst.root == null) {
					Integer rootID = nodeList.keySet().iterator().next();
					mst.root = nodeList.get(rootID);
					assert ( mst.root != null );
				}
			}
		}
		// Setup if mst has alignment information for all nodes
		mst.haveAlignmentInfo = haveAlignInfo;
		// return the newly loaded/created mst.
		return mst;
	}
	
	/**
	 * Helper method to process a comma separated set of values
	 * representing a MST node.
	 * 
	 *  This method is a helper method that is used to parse a data
	 *  line from the MST file and convert it to a MSTNode. This
	 *  method reads and validates the data. It then creates a MSTNode
	 *  and adds it to its parent (if one is present) and to the nodeList.
	 * 
	 * @param nodeList The list of nodes that have been read so far.
	 * 
	 * @param line The line containing node data to be processed and
	 * converted to a MSTNode.
	 * 
	 * @return This method returns true if the line contained an alignment
	 * information.
	 * 
	 * @throws IOException This method throws an exception if the data
	 * was invalid or not read.
	 */
	protected static boolean makeMSTNode(HashMap<Integer, MSTNode> nodeList, 
			String line) throws IOException {
		// Extract the ',' separated values. The values are in the form:
		// <parentIdx>, <estIdx>, <metric>, <alignment>
		String[] entries = line.split(",");
		// Ensure we have 3 or 4 entries exactly
		if ((entries.length != 3) && (entries.length != 4)) {
			throw new IOException("Invalid data line in MST file " +
					"(line: " + line + ")");
		}
		Integer parentIdx = Integer.parseInt(entries[0]);
		int   estIdx      = Integer.parseInt(entries[1]);
		float metric      = Float.parseFloat(entries[2]);
		int   alignment   = 0;
		boolean haveAlign = false;
		if (entries.length == 4) {
			alignment = Integer.parseInt(entries[3]);
			haveAlign = true; // Track this node has alignment information
		}
		// Ensure the the estIndex and parentIdx are valid.
		if ((parentIdx < -1) || (!nodeList.containsKey(parentIdx))) {
			throw new IOException("Invalid parent index in MST file " +
					"(line: " + line + ")");
		}
		if (estIdx < 0) {
			throw new IOException("Invalid EST index in MST file " +
					"(line: " + line + ")");
		}
		// Get the actual parent node entry if applicable.
		MSTNode parent = (parentIdx != -1) ? nodeList.get(parentIdx) : null;
		// Create the new MST node.
		MSTNode child  = new MSTNode(parent, estIdx, metric, alignment);
		// Add the child to the parent node
		if (parent != null) {
			parent.addChild(child);
		}
		// Add the EST to the list of ESTs for future reference
		nodeList.put(new Integer(estIdx), child);
		// Return if the new node has alignment information
		return haveAlign;
	}
	
	/**
	 * This is a helper method that is used to parse a line of
	 * meta data entry (line starts with a '#' character) and convert 
	 * it to a a Pair containing a name, value pair and returns the 
	 * meta data as a pair. It assumes that the name and value are
	 * separated by ':'. 
	 * 
	 * @param line The line from the MST file to be processed.
	 * 
	 * @return A pair object containing the name, value pair.
	 */
	protected static Pair makeMetadataEntry(String line) {
		// Locate the ":" in the line and use that as the separator
		// between name:value.
		int colonPos = line.indexOf(':');
		String name  = line;
		String value = null;
		// Extract value only if ':' was found.
		if (colonPos != -1) {
			// Extract name and value.
			name  = line.substring(1, colonPos).trim();
			value = line.substring(colonPos + 1).trim();
		}
		// Create and store the information
		return new Pair(name, value);
	}
	
	/**
	 * The constructor creates an empty MST object. This method is
	 * called from the loastMST method. This object is filled in
	 * later on as data is read from the MST file. 
	 * 
	 * @param fileName The absolute path to the file from where the
	 * MST data was loaded. This file name is used as an identifier
	 * to locate the files.
	 */
	private MST(String fileName) {
		this.fileName = fileName;
		this.root     = null;
		this.metadata = new ArrayList<Pair>();
		this.haveAlignmentInfo = false;
	}
	
	/**
	 * The file name from where the data has been read. This is typically
	 * the absolute path of the file from where the data was read.
	 */
	private String fileName;
	
	/**
	 * The root of the MST node. Typically there is at least one root
	 * node.
	 */
	private MSTNode root;
	
	/**
	 * Flag to indicate if the MST data contains initial, pre-assembly alignment
	 * metric that is useful to detect where overlaps between two adjacent 
	 * (parent-child) fragments occur to obtain the given alignment metric. This
	 * value is set when the MST is loaded from a data file.
	 */
	private boolean haveAlignmentInfo;
	
	/**
	 * The set of meta data that was loaded from the MST file. The
	 * meta data is stored as a list of name, value pairs.
	 */
	private ArrayList<Pair> metadata;
}
