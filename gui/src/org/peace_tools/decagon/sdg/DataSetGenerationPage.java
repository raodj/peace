//--------------------------------------------------------------------
//
// This file is part of PEACE.
// 
// PEACE is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// PEACE is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with PEACE.  If not, see <http://www.gnu.org/licenses/>.
// 
// Miami University makes no representations or warranties about the
// suitability of the software, either express or implied, including
// but not limited to the implied warranties of merchantability,
// fitness for a particular purpose, or non-infringement.  Miami
// University shall not be liable for any damages suffered by licensee
// as a result of using, result of using, modifying or distributing
// this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of GNU General Public License (version 3).
//
// Authors:   Dhananjai M. Rao              raodm@muohio.edu
//
//---------------------------------------------------------------------

package org.peace_tools.decagon.sdg;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.swing.JLabel;
import javax.swing.border.EmptyBorder;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;

import org.peace_tools.core.PEACEProperties;
import org.peace_tools.core.session.ServerSession;
import org.peace_tools.core.session.SessionFactory;
import org.peace_tools.decagon.PropertyKeys;
import org.peace_tools.decagon.jaxb.Parameter;
import org.peace_tools.generic.BackgroundTask;
import org.peace_tools.generic.GenericWizardPage;
import org.peace_tools.generic.ProcessOutputDisplay.StyleKind;
import org.peace_tools.generic.ProgrammerLog;
import org.peace_tools.generic.Utilities;
import org.peace_tools.generic.WizardDialog;
import org.peace_tools.workspace.DataFileStats;
import org.peace_tools.workspace.DataSet;
import org.peace_tools.workspace.DataSet.DataFileType;
import org.peace_tools.workspace.SeqTechType;
import org.peace_tools.workspace.Server;
import org.peace_tools.workspace.Workspace;

/**
 * This class serves as the penultimate page in the SyntheticDataSetGenerator. 
 * This page performs the various tasks associated with generation of
 * the synthetic data sets by calling MultiSim multiple times and 
 * finally merging the files generated by MultiSim.
 */
public class DataSetGenerationPage extends GenericWizardPage implements BackgroundTask.UserTask {
	/**
	 * The constructor. The constructor does not have any special
	 * operations to perform. The GUI objects are created in the
	 * {@link #pageChanged(WizardDialog, int, int)} method once
	 * the user has decided on the different types of sequences
	 * to be generated.
	 * 
	 * @param wizard The wizard that logically owns this page.
	 */
	public DataSetGenerationPage(SyntheticDataSetGenerator dcm) {
		this.sdg = dcm;
		assert(this.sdg != null);
		// Setup the title(s) for this page and border
		setTitle("Generation", "Generating synthetic reads");
		setBorder(new EmptyBorder(5, 5, 5, 5));
		// Nothing else to be done for now.
	}
	
	/**
	 * This method is called just before this page is to be displayed.
	 * This method triggers the various operations related to generation
	 * of synthetic data sets. This method performs the following tasks:
	 * 
	 * <ol>
	 * 	<li>It creates a BackgroundTask object with various steps and 
	 * adds the GUI components generated by it to this page for display
	 * to the user</li>
	 * 
	 * <li>It disables various buttons and kick starts the background
	 * task to perform various operations. This causes the {@link #run(BackgroundTask)}
	 * method to be invoked, which further coordinates the various tasks.</li>
	 * 
	 * </ol>  
	 * 
	 * @param dialog The wizard dialog that logically owns this page. This
	 * value is not used.
	 * 
	 * @param currPage The zero-based index number for the current wizard
	 * page. This value is not used.
	 * 
	 * @param prevPage The zero-based index of the previous wizard page
	 * from where the user switched to the current page. This value is
	 * not used.
	 */
	@Override
	public void pageChanged(WizardDialog dialog, int currPage, int prevPage) {
		// Create the background task with progress display GUI components.
		// For this we need to determine the various steps to be performed.
		ArrayList<String> stepList = new ArrayList<String>();
		stepList.add("Make temporary directory");
		if (sdg.getParametersPage(SeqTechType.SANGER).isTechEnabled()) {
			stepList.add("Generate Sanger-type reads");
		}
		if (sdg.getParametersPage(SeqTechType.R454).isTechEnabled()) {
			stepList.add("Generate 454-type reads");
		}
		if (sdg.getParametersPage(SeqTechType.ILLUMINA).isTechEnabled()) {
			stepList.add("Generate Illumina-type reads");
		}
		stepList.add("Randomly merge reads");
		stepList.add("Add entry & clean up");
		// Convert array list to a string array.
		final String[] steps = stepList.toArray(new String[stepList.size()]);
		// Create the background task.
		final JLabel infoLabel = new JLabel("The synthetic data set is being generated. " +
				"Please wait...", Utilities.getIcon("images/24x24/Warning.png"),
						JLabel.LEFT);
		bgTask = new BackgroundTask(this, infoLabel, false, steps, true, false,
				false, 2, true, false, false, null);
		// Make the logs a bit bigger to make it look good.
		bgTask.getLog().getTextPane().setPreferredSize(new Dimension(2400, 100));
		// Add the progress panel to this window.
		this.add(bgTask.getTopPanel(), BorderLayout.CENTER);
		// Disable various buttons to lock focus on this page.
		dialog.setButtonStatus(0, 0, 1);
		// Kick start the background thread which calls the #run() method in
		// this class.
		bgTask.start(false, this, null, null);
	}
		
	/**
	 * A reference to the wizard dialog that logically owns this
	 * page. This reference is used to obtain summary information
	 * from various pages constituting this wizard.
	 */
	private final SyntheticDataSetGenerator sdg;

	/**
	 * The background task object that helps to perform various operations
	 * in the background while ensuring the GUI is responsive in the
	 * foreground.
	 */
	private BackgroundTask bgTask;
	
	/**
	 * A serialization UID to keep the compiler happy.
	 */
	private static final long serialVersionUID = 8538523942750752144L;

	@Override
	public void run(BackgroundTask bTask) throws Exception {
		// Do the first step of creating a temporary directory
		final File tempDir = createTmpDirectory();
		bTask.updateProgress();
		// The following hash-map maintains error rates reported by 
		// MetaSim for the various sequencing technologies.
		HashMap<SeqTechType, DataFileStats> errorRates = new HashMap<SeqTechType, DataFileStats>(4); 
		// Create sequences for various technologies (if enabled) and 
		// obtain error rates for analysis.
		DataFileStats errDfs = null;
		if ((errDfs = checkAndRunMetaSim(tempDir, SeqTechType.SANGER)) != null) {
			errorRates.put(SeqTechType.SANGER, errDfs);
			bTask.updateProgress();
		}
		if ((errDfs = checkAndRunMetaSim(tempDir, SeqTechType.R454)) != null) {
			errorRates.put(SeqTechType.R454, errDfs);
			bTask.updateProgress();
		}
		if ((errDfs = checkAndRunMetaSim(tempDir, SeqTechType.ILLUMINA)) != null) {
			errorRates.put(SeqTechType.ILLUMINA, errDfs);
			bTask.updateProgress();
		}
		// Randomly merge the generated file into a single FASTA file.
		final ArrayList<DataFileStats> seqStats = mergeFiles(tempDir);
		bTask.updateProgress();
		// Now create the workspace entry with the generated file.
		DataSet ds = new DataSet(Workspace.get().reserveID(),
				sdg.getTargetGeneratedFile(), sdg.getDescription(), 
				DataFileType.FASTA);
		// Add error rates to each of the seqStats entries to complete
		// all the necessary statistical information about each file
		for(DataFileStats dfs: seqStats) {
			DataFileStats errStats = errorRates.get(dfs.getTechType());
			if (errStats != null) {
				dfs.setSeqInfo(dfs.getTechType(), errStats.getInsErrorRate(),
						errStats.getDelErrorRate(), errStats.getSubErrorRate());
			}
			ds.addStats(dfs);
		}
		// Add data set to workspace.
		Workspace.get().addDataSet(ds);
		// Clean up the temporary directory.
		deleteDir(tempDir);
		bTask.updateProgress();
	}

	@Override
	public void done(BackgroundTask bTask) {
		// Update status of wizard buttons.
		sdg.setButtonStatus(0, 1, 0);
		// Display the overall status to the user.
		bTask.showMessage("Synthetic data set created successfully",
				"Error generating Synthetic data set");
	}

	@Override
	public void dialogClosed(BackgroundTask bTask) {
		// Nothing to be done here for now. This method is merely
		// present to satisfy the BackgroundTask  interface.
	}
	
	/**
	 * Helper method to clean-up generated files in the temporary directory
	 * and delete the temporary directory.
	 *  
	 * @param tempDir The temporary directory to be deleted. 
	 */
	private void deleteDir(File tempDir) {
		bgTask.log("\nDeleting Temporary working directory\n", StyleKind.HEADING);
		final File[] subFiles = tempDir.listFiles();
		for(File subFile: subFiles) {
			bgTask.log("  Deleting temporary file: " + subFile.getName() + "\n");
			subFile.delete();
		}
		bgTask.log("  Deleting temporary directory.\n");
		tempDir.delete();
	}
	
	/**
	 * Helper method to locate a generated file with a given suffix in
	 * a given directory.
	 * 
	 * This method is a helper method that is invoked from the
	 * {@link #mergeFiles(File)} method to locate a generated file
	 * for a given technology. MetaSim generates files for a given
	 * technology with suffixes in the form <code>-Sanger.fna</code>
	 * or <code>-Empirical.fna</code> or <code>-454.fna</code>. This
	 * method checks the sub-files within the temporary working
	 * directory and returns the matching entry.
	 * 
	 * @param tempDir The temporary working directory in which to
	 * search for files.
	 * 
	 * @param suffix The file ending/suffix string to be used to locate
	 * a given file.
	 * 
	 * @return The full path to the file if found. Otherwise this method
	 * returns null.
	 */
	private String findFile(final File tempDir, final String suffix) {
		final File[] subFiles = tempDir.listFiles();
		for(File subFile: subFiles) {
			final String fullPath = subFile.getAbsolutePath();
			if (fullPath.endsWith(suffix)) {
				// Found match
				return fullPath;
			}
		}
		return null;
	}

	/**
	 * Helper method to merge the generated files in the temporary
	 * directory.
	 * 
	 * This is a helper method that is called from the 
	 * {@link #run(BackgroundTask)} method to merge one or more 
	 * generated FASTA files to the final target file. This method
	 * is invoked even for one FASTA file in order to randomly
	 * sort the entries in the file. This method searches the
	 * temporary work directory for generated files (using the
	 * {@link #findFile(File, String)} helper method) and uses
	 * the FASTAFileMerger to merge the generated files.
	 * 
	 * @param tempDir The temporary work directory where MetaSim
	 * has generated files.
	 * 
	 * @return This method returns the aggregate file statistics
	 * of each FASTA file merged by this method. 
	 * 
	 * @throws Exception This method exposes any exception that
	 * occurs when merging files.
	 */
	private ArrayList<DataFileStats> mergeFiles(final File tempDir) throws Exception {
		bgTask.log("\nRandomly Merging generated reads\n", StyleKind.HEADING);
		// Create the FASTA file merger utility that performs the actual merge
		FASTAFileMerger ffm = new FASTAFileMerger();
		ffm.setBackgroundTask(bgTask);
		// Setup the generated FASTA files to be merged
		if (sdg.getParametersPage(SeqTechType.SANGER).isTechEnabled()) {
			// Get generated file for Sanger reads
			ffm.addSourceFile(findFile(tempDir, "-Sanger.fna"), 
					sdg.getCount(SeqTechType.SANGER), SeqTechType.SANGER);
		}
		if (sdg.getParametersPage(SeqTechType.R454).isTechEnabled()) {
			// Get generated file for 454 reads
			ffm.addSourceFile(findFile(tempDir, "-454.fna"), 
					sdg.getCount(SeqTechType.R454), SeqTechType.R454);
		}
		if (sdg.getParametersPage(SeqTechType.ILLUMINA).isTechEnabled()) {
			// Get generated file for Illumina reads
			ffm.addSourceFile(findFile(tempDir, "-Empirical.fna"), 
					sdg.getCount(SeqTechType.ILLUMINA), SeqTechType.ILLUMINA);
		}
		// Now get the FASTA file merger utility to merge files. This will
		// give us statistics about number of reads, average length, etc.
		ArrayList<DataFileStats> statsList = ffm.merge(sdg.getTargetGeneratedFile(), sdg);
		return statsList;
	}
	
	/**
	 * Helper method to setup empirical error model for MetaSim.
	 * 
	 * MetaSim requires an error model data file for generating empirical/
	 * Illumina type reads. This configuration file is contained in the
	 * the PEACE jar file. However, MetaSim cannot obtain this file directly
	 * from PEACE jar file. Consequently, this method extracts the required
	 * file from PEACE jar and places it in the temporary working directory
	 * for MetaSim to use. Once the file has been successfully extracted
	 * this method then returns the necessary command-line argument to
	 * be added to MetaSim command-line argument. 
	 * 
	 * @param tmpDir The temporary working directory to where the empirical
	 * data file is the extracted and placed.
	 * 
	 * @param readLenParam The input parameter associated with the read
	 * length which the user has specified. The read-length value is used
	 * to determine the empirical data file to be used.
	 * 
	 * @param cmdArgs The list of arguments to which the necessary command-line
	 * arguments are to be added. If this parameter is null, then the
	 * command-line parameters are not added.
	 * 
	 * @return Once the file has been successfully extracted
	 * this method then returns the necessary command-line argument to
	 * be added to MetaSim command-line argument.
	 *  
	 * @throws IOException This method exposes the exceptions that may  
	 * occur during the various i/o operations performed by this class.
	 */
	private String setupEmpiricalDataFile(final File tmpDir,
			final Parameter readLenParam, List<String> cmdArgs) throws IOException {
		// Use the read length value to determine empirical data file name.
		final String dataFileName = 
			"errormodel-" + readLenParam.getValue() + "bp.mconf";
		final String targetFileName = tmpDir.getAbsolutePath() + File.separator + dataFileName;
		// Create log entry to help troubleshoot issues
		bgTask.log("Creating Metasim empirical data file: " + targetFileName + "\n", StyleKind.INFO);
		// Copy the data file from our internal resource to the target path
		InputStream src     = Utilities.getStream("decagon/" + dataFileName);
		OutputStream dest   = new FileOutputStream(targetFileName);
		final byte buffer[] = new byte[4096];
		int bytesRead       = -1;
		while ((bytesRead = src.read(buffer)) != -1) {
			dest.write(buffer, 0, bytesRead);
		}
		// Close the streams (as we are done copying)
		src.close();
		dest.close();
		// Log success
		bgTask.log("Successfully created Metasim empirical data file.\n", StyleKind.INFO);
		// Add necessary parameters to command-line arguments
		if (cmdArgs != null) {
			cmdArgs.add(readLenParam.getCmdLine());
			cmdArgs.add(targetFileName);
		}
		// Return the revised parameter with the correct file name.
		return readLenParam.getCmdLine() + " " + targetFileName; 
	}
	
	/**
	 * Convenience method to extract a number that occurs after a given phrase in
	 * a string.
	 * 
	 * This is a helper method that is used in the {@link #checkLogsAndGetStats()}
	 * method to extract integer values from logs. For example given
	 * a string <code>"Generated 201035 Base Pairs\nInsertions: 6009"</code>
	 * and the phrase <code>"Insertions: "</code>, this method returns 
	 * 6009. 
	 * 
	 * @param logEntries The log entries in which to search for the given
	 * phrase. This method uses the {@link Utilities#getWordAfter(String, String)}
	 * method to extract the word and then converts it to a number.
	 * 
	 * @param phrase The phrase to search for. The number to be extracted
	 * must occur right after this phrase.
	 * 
	 * @return If the number was found an extracted successfully, then this
	 * method returns the value. Otherwise this method returns -1. There is
	 * no to distinguish between -1 that actually occurs in the log versus
	 * an error condition.
	 */
	int findNumberAfter(final String logEntries, final String phrase) {
		int  retVal         = -1;
		final String numStr = Utilities.getWordAfter(logEntries, phrase);
		try {
			// Convert string to integer.
			retVal = Integer.parseInt(numStr);
		} catch  (NumberFormatException nfe) {
			ProgrammerLog.log(nfe);
		}
		return retVal;
	}
	
	/**
	 * Convenience method to detect errors in MetaSim output logs.
	 * 
	 * Even when exceptions occur MetaSim incorrectly returns exit code of zero.
	 * So to try and detect errors correctly, this method searches the logs for the 
	 * word "FAIL" that signifies an error in MetaSim execution. If no failures
	 * were detected, then this method extracts the nucleotide information reported
	 * by MetaSim to obtain the number of insert, delete, and substitution
	 * error rates. The output from MetaSim looks like this:
	 * 
	 * <code>Generated 200 Reads
	 * Average Read Length is 1005.18 Base Pairs
	 * Processed 201086 Base Pairs
	 * Generated 201035 Base Pairs
	 * Insertions: 6009
	 * Deletions: 6060
	 * Substitutions: 18118
	 * Read data saved as `all_zf_cdnas.reduced-Sanger.fna'.
	 * Done.
	 * </code>
	 * 
	 * This method uses the above information to extract the rates and
	 * set it in the statistics object passed-in as the parameter.
	 * 
	 * @param techType The sequencing technology type for which statistics
	 * is being obtained. This value is used to set the insertion, deletion,
	 * and substitution error rates in the given DataFileStats object (second 
	 * parameter).
	 * 
	 * @param dfs The statistics object in which the error rates extracted
	 * from the logs are to be set.
	 * 
	 * @return This method returns true if no errors were found. If errors were
	 * found this method returns false. 
	 */
	private boolean checkLogsAndGetStats(SeqTechType techType, DataFileStats dfs) {
		final DefaultStyledDocument log = bgTask.getLog().getDoc();
		final int logSize               = log.getLength();
		final int startPos              = Math.max(0, logSize - 1024);
		String  logEntries              = "";
		// Extract last 1024 characters of log entries from the log.
		try {
			logEntries = log.getText(startPos, logSize - startPos);
		} catch (BadLocationException e) {
			ProgrammerLog.log(e);
			return false; // flag as failure.
		}
		// Check if generation was successful.
		if (logEntries.indexOf("FAIL") != -1) {
			// Generation was unsuccessful
			return false;
		}
		// Generation was successful. Extract necessary statistics.
		// Obtain the relevant portion of the logs that start with "Processed " word.
		final int statStartPos     = logEntries.indexOf("Processed ");
		logEntries                 = logEntries.substring(statStartPos);
		// First extract the total number of nucleotides generated.
		final float totalBaseCount = findNumberAfter(logEntries, "Generated ");
		final float insErrCount    = findNumberAfter(logEntries, "Insertions: ");
		final float delErrCount    = findNumberAfter(logEntries, "Deletions: ");
		final float subErrCount    = findNumberAfter(logEntries, "Substitutions: ");
		// Update the statistics about the generated data set
		dfs.setSeqInfo(techType, insErrCount / totalBaseCount, 
				delErrCount / totalBaseCount, subErrCount / totalBaseCount);
		// return success
		return true;
	}
	/**
	 * Helper method to check and generate synthetic reads using MetaSim.
	 * 
	 * @param psgh
	 */
	private DataFileStats checkAndRunMetaSim(final File tmpDir, 
			final SeqTechType techType) throws Exception {
		final MetaSimParametersPage wizPage = sdg.getParametersPage(techType);
		if (!wizPage.isTechEnabled()) {
			// this technology is not enabled. Nothing further to do.
			bgTask.log("Skipping generation of " + wizPage.getTechType() + ".", 
					StyleKind.INFO);
			return null;
		}
		// Start informational section.
		bgTask.log("\nGenerating " + wizPage.getTechType() + 
				" Reads via MetaSim\n", StyleKind.HEADING);

		// Create the command-line string to run Meta Sim.
		// First set the metasim executable path and some standard parameters
		// to the beginning of cmdArgs. Get the path to MetaSim executable first.
		PEACEProperties props = PEACEProperties.get();
		String cmdArgs = props.getProperty(PropertyKeys.METASIM_PATH);
		// Add the standard set of parameters
		cmdArgs += " " + wizPage.getParameterSetGUIHelper().getCmdLine();
		// Add flag to place generated files in the temporary work directory.
		cmdArgs += " -d " + tmpDir.getAbsolutePath() + " ";
		// If the technology type is Illumina we need to setup the
		// empirical data file for MetaSim to use.
		if (SeqTechType.ILLUMINA.equals(wizPage.getTechType())) {
			// Get the length of the ignored parameter to determine file to use
			final Parameter readLenParam = 
				wizPage.getParameterSetGUIHelper().getParameter("IlluminaAvgLen");
			// Use a helper method to setup the empirical data file.
			cmdArgs += " " + setupEmpiricalDataFile(tmpDir, readLenParam, null);
		}
		// Finally add the source FASTA file.
		cmdArgs += " " + sdg.getSourceGeneFile();
		
		// Let the user know that we are running MetaSim
		bgTask.log("Running MetaSim with command line: " + cmdArgs + "\n", StyleKind.INFO);
		// Start meta sim on the local machine.
		ServerSession session = SessionFactory.createSession(this, 
				Server.createLocalServer("SyntheticDataSetGenerator"));
		final int exitCode = session.exec(cmdArgs, bgTask.getLog().getDoc());
		// Check if MetaSim's exit code looks good.
		bgTask.log("\nExit code = " + exitCode + "\n", StyleKind.INFO);
		// Even when exceptions occur MetaSim incorrectly returns exit code of zero.
		// So here we search the logs for the word "FAILED" that signifies an error
		DataFileStats dfs = new DataFileStats("", 0, -1, -1, -1, -1, -1);
		if ((exitCode != 0) || !checkLogsAndGetStats(techType, dfs)) {
			throw new IOException("Error generating data set via MetSim.");
		}
		return dfs;
	}
	
	/**
	 * Helper method to create a temporary directory where
	 * MultiSim files are temporarily stored.
	 * 
	 * This method tries three times to create a temporary 
	 * directory. If all three attempts fail, then this method
	 * returns null.
	 * 
	 * @return On successfully creating a temporary directory
	 * this method returns a File object associated with it.
	 * 
	 * @exception IOException This method exposes any i/o exceptions that
	 * occur when creating the temporary directory.
	 */
	private File createTmpDirectory() throws IOException {
		bgTask.log("Create Temporary working directory\n", StyleKind.HEADING);
		for(int trial = 0; (trial < 3); trial++) {
			// First create a temporary file to obtain a valid temporary file name.
			File tempFile = File.createTempFile("DECAGON_", "_tmp");
			bgTask.log("Obtained temporary file name: " + tempFile + "\n", StyleKind.INFO);
			// Use temporary file name to create name for directory.
			File tempDir = new File(tempFile.getAbsolutePath() + "_dir");
			// Remove temporary file as we no longer need it
			tempFile.delete();
			if (tempDir.mkdir()) {
				// Successfully created temporary directory.
				bgTask.log("Created temporary directory: " + tempDir + "\n", StyleKind.INFO);
				tempDir.deleteOnExit();
				return tempDir;
			}
		}
		throw new IOException("Unable to create temporary directory (after 3 tries)");
	}
}
