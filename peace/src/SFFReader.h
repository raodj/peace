#ifndef SFF_READER_H
#define SFF_READER_H

//--------------------------------------------------------------------
//
// This file is part of PEACE.
// 
// PEACE is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// PEACE is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with PEACE.  If not, see <http://www.gnu.org/licenses/>.
// 
// Miami University makes no representations or warranties about the
// suitability of the software, either express or implied, including
// but not limited to the implied warranties of merchantability,
// fitness for a particular purpose, or non-infringement.  Miami
// University shall not be liable for any damages suffered by licensee
// as a result of using, modifying or distributing this software or
// its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of GNU General Public License (version 3).
//
// Authors:   Dhananjai M. Rao          raodm@muohio.edu
//
//---------------------------------------------------------------------

#include <fstream>
#include "EST.h"

/** \file SFFReader.h
    
    A class to read sequences from a Standard Flowgram Format (SFF) file.

    This file contains the class declaration for the SFFReader. The
    SFFReader is used to read sequence data from a SFF data file.
    Additional documentation regarding the API provided by this class
    is available with the class documentation.
*/

/** A class to read sequences from a Standard Flowgram Format (SFF) file.

    <p>This class is a helper class that is used to read data from a
    SFF file.  An SFF file has a specific file format that is used to
    efficiently incorporate data generated by next generation 454
    sequencing technologies.  The 454 reads differ from standard
    sequencing reads in that the 454 data does not provide individual
    base measurements from which basecalls can be derived.  Instead,
    it provides measurements that estimate the length of the next
    homopolymer stretch in the sequence (i.e., in \c "AAATGG", \c
    "AAA" is a 3-mer stretch of A's, "T" is a 1-mer stretch of T's and
    "GG" is a 2-mer stretch of G's). A basecall'ed sequence is then
    derived by converting each estimate into a homopolymer stretch of
    that length and concatenating the homopolymers.</p>

    The file format consists of the following sections:

    <ol>

    <li>A common header section that occurs only once in the file</li>

    <li>For each read stored in the file there is a read header
    section and a read data section.</li>

    </ol>

    Further details on the SFF file format can be found at: http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=formats#sff
*/
class SFFReader {
public:
    /** Create a SFFReader to load SFF data from a given file.

        This constructor must be used to create a SFFReader object to
        load SFF binary data from a given file.

        \param[in] fileName The SFF data file (with optional path
        prefix) from where the data is to be loaded.
    */
    SFFReader(const std::string& fileName);

	/** Destructor.

		The destructor closes the internal file stream used to read
		data from the SFF file.
	*/
	~SFFReader();
	
    /** Determine if the SFF file is still valid.

        This method can be used to check to ensure that the SFF file
        is still valid.  This method returns true only if both of
        the following conditions are true:

        <ol>

        <li> The file has a valid SFF header and the header was
        successfully read and validated.</li>

        <li>The actual physical file is still good and can be used for
        further processing.</li>
        
        </ol>
    */
    inline bool isValid() { return hasValidSFFHeader && sffFile.good(); }

    /** Determine number of reads (aka sequences/fragments) yet to be
        read from the file.

        This method can be used to determine the number of reads yet
        to be read/processed from the SFF file.

        \return The number of pending reads. This method returns zero
        if no more reads are pending.
    */
    inline unsigned int getPendingReads() const { return pendingReads; }

    /** Read the next read from the SFF file.

        This method must be used to obtain the next read from the SFF
        file appropriately populated into an EST object.  This method
        must be invoked only if the getPendingReads() method returns a
        non-zero value and the isValid() method returns
        true. Otherwise (that is, a read is not available or if the
        file has been flagged as being invalid) then this method
        returns NULL.

        \note It is the responsibility of the caller to delete the EST
        object returned by this method after it has been used.  This
        method uses EST::create() method to create the EST entry.
        Consequently, the EST entry is automaticlaly added to the
        global EST list.

		\param[in] maskBases If this flag is true, then all lowercase
		bases are converted to 'N' rather than uppercase characters,
		causing them to be ignored by downstream processing.
		
        \return A newly created (on the heap) EST object containing
        the next read in the SFF file.  The number of pending reads is
        decremented after this method call.  On errors this method
        returns NULL after setting pending reads to zero and
        invalidating the file (causing isValid() method to return \c
        false).
    */
    EST* getNextRead(const bool maskBases = true);
    
protected:
    /** Helper method to read the SFF common header.

        <p>This is a helper method that is invoked only once from the
        constructor to read the SFF header.  This method reads and
        validates the SFF header.  In addition, it saves the necessary
        information from the header into various instance variables.
        To fully understand the operations in this method you must
        review the SFF header format at: http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=formats#sff</p>
        
        <p>This method first reads the standard 31-bytes that the SFF
        file absolutely must have as a part of the SFF header. This
        method reads 31-bytes and then appropriately type-cast them to
        avoid dealing withpacked structures etc. across multiple C++
        compilers. Ideally we would define the various fileds as a
        C-struct and read them in one swoop.  However, that makes
        assumptions that the C-struct is aliened at the byte
        boundaries and complier packs fields in the correct order
        etc. Once the 31-bytes have been validated, this method
        positions the file pointer right after the common header
        section.</p>

        \note This method must be called only once right after the
        file is opened.
    */
    void loadSFFHeader();

	/** Helper method to combine two parts of a given number into a
		single number.

		This method is used to combine two numeric, integer values,
		representing most significant and least significant
		components, into a single larger value.  This method is
		primarily used to facilitate conversion from Big Endian binary
		formats stored in the SFF file to local architecture.  Here is
		a short example illustrating the use of this method:

		\code
		int result = SFFReader::combine<int, short>(0x70, 0x0B);
		// result will be 0x700B
		\endcode

		\tparam retType The data type of the return value.  This data
		type should be chosen to be twice as large as the paramType.
		For example, if paramType is short (2 bytes), then retType
		should be <i>at least</i> int (4 bytes).

		\tparam retType The data type of the two values (msb and lsb)
		to be combined together into a single numeric value.
		
		\param[in] msb The most significant component to be combined
		into a single numeric value.

		\param[in] lsb The least significant component to be combined
		into a single numeric value.
	*/
    template<typename retType, typename paramType>
    static inline
    retType combine(const paramType& msb, const paramType& lsb) {
        retType retVal = msb;
        retVal <<= (sizeof(paramType) << 3); // byteSize * 8 == bits
        retVal   = (retType) (retVal | lsb);
        return retVal;
	}

private:
    /** The actual input stream from where the SFF data is being read.

        This stream is initialized in the constructor when the
        SFFReader is created.  This stream is opened as a binary
        stream.
    */
    std::ifstream sffFile;

    /** Flag to indicate if this file has a valid SFF header.

        This flag is set in the loadSFFHeader() method to indicate if
        a valid SFF header was read from the input stream.
    */
    bool hasValidSFFHeader;

    /** Number of reads (aka fragments/sequences) in the SFF file.

        This instance variable contains the number of reads in the SFF
        file.  This value is set when the SFF header is loaded by the
        loadSFFHeader() method.
    */
    unsigned int readCount;

    /** Instance variable to track the number of reads yet to be read.

        This instance variable is initialized to the number of reads
        in a SFF file. Each time a sequence is read, this value is
        decremented.  When this value reaches zero then all the
        sequences in the SFF file have been read.
    */
    unsigned int pendingReads;

    /** The number of flow entries for each read in the SFF file.

        This instance variable contains the number of flows per read
        in the SFF file.  This value is set when the SFF header is
        loaded by the loadSFFHeader() method.  This value is used to
        skip over the flowgram values in the getNextRead() method.
    */
    unsigned short flowsPerRead;

    /** The logical file offset where an index is stored.

        This instance variable contains the logical offset within the
        SFF file where an index is stored.  This value is set when the
        SFF header is loaded by the loadSFFHeader() method.  This
        value is used to skip over the index in the getNextRead()
        method.
    */
    unsigned long long indexOffset;

    /** The size (in number of bytes) of the index.

        This instance variable contains the size (in number of bytes)
        within the SFF file where an index is stored.  This value is
        set when the SFF header is loaded by the loadSFFHeader()
        method.  This value is used to skip over the index in the
        getNextRead() method.
    */
    unsigned int indexSize;
};

#endif
