//--------------------------------------------------------------------
//
// This file is part of PEACE.
// 
// PEACE is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// PEACE is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with PEACE.  If not, see <http://www.gnu.org/licenses/>.
// 
// Miami University makes no representations or warranties about the
// suitability of the software, either express or implied, including
// but not limited to the implied warranties of merchantability,
// fitness for a particular purpose, or non-infringement.  Miami
// University shall not be liable for any damages suffered by licensee
// as a result of using, result of using, modifying or distributing
// this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of GNU General Public License (version 3).
//
// Authors:   Dhananjai M. Rao          raodm@muohio.edu
//
//---------------------------------------------------------------------

package org.peace_tools.data;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;


/** A class to read sequences from a Standard Flowgram Format (SFF) file. 
 * 
 * <p>This class is a helper class that is used to read data from a
 * SFF file.  An SFF file has a specific file format that is used to 
 * efficiently incorporate data generated by next generation 454 
 * sequencing technologies.  The 454 reads differ from standard 
 * sequencing reads in that the 454 data does not provide individual 
 * base measurements from which basecalls can be derived.  Instead, 
 * it provides measurements that estimate the length of the next 
 * homopolymer stretch in the sequence (i.e., in \c "AAATGG", \c 
 * "AAA" is a 3-mer stretch of A's, "T" is a 1-mer stretch of T's and 
 * "GG" is a 2-mer stretch of G's). A basecall'ed sequence is then 
 * derived by converting each estimate into a homopolymer stretch of 
 * that length and concatenating the homopolymers.</p>
 * 
 * The file format consists of the following sections: 
 * <ol>
 * <li>A common header section that occurs only once in the file</li>
 * <li>For each read stored in the file there is a read header 
 * section and a read data section.</li>
 * </ol>
 * 
 * Further details on the SFF file format can be found at: 
 * http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=formats#sff
*/
public class SFFReader {
    /** Create a SFFReader to load SFF data from a given file. 
     * 
     * This constructor must be used to create a SFFReader object to 
     * load SFF binary data from a given file. This method attempts
     * to open the file, read the SFF header, and validate the header.
     * 
     * @param fileName The SFF data file (with optional path prefix) 
     * from where the data is to be loaded.
     *  
     * @throws IOException This method throws an exception if the
     * file was not found or an error occurred when attempting to read the
     *  
     */
	public SFFReader(String fileName) throws IOException {
		// If we can open the file, simply delegate rest of the tasks
		// to the overloaded constructor
	    this(new FileInputStream(fileName));
	}
	
	   /** Create a SFFReader to load SFF data from a given file. 
     * 
     * This constructor must be used to create a SFFReader object to 
     * load SFF binary data from a given file. This method attempts
     * to open the file, read the SFF header, and validate the header.
     * 
     * @param is The input stream containing the SFF information
     * from where the data is to be loaded.
     *  
     * @throws IOException This method throws an exception if the
     * file was not found or an error occurred when attempting to read the 
     */
	public SFFReader(InputStream is) throws IOException {
	    // Initialize instance variables to default values
	    hasValidSFFHeader = false;
	    pendingReads      = 0;
	    readCount         = 0;
	    flowsPerRead      = 0;
	    indexOffset       = 0;
	    indexSize         = 0;
	    bytesRead         = 0;
	    sffFile           = null;
	    // Wrap the input stream in a buffered stream and in a 
	    // DataStream to ease reading binary data.
	    sffFile = new DataInputStream(new BufferedInputStream(is));
	    // Now that we have a valid stream, lets try to read the
	    // header and process it.
        loadSFFHeader();
	}
	
    /** Determine if the SFF file is still valid. 
     * 
     * This method can be used to check to ensure that the SFF file
     * is still valid.  This method returns true only if both of 
     * the following conditions are true: 
     * 
     * <ol> 
     * 
     * <li> The file has a valid SFF header and the header was 
     * successfully read and validated.</li> 
     * 
     * </ol>
     * 
     * Note that this method has a subtle difference in operation 
     * from its C++ counterpart.
     */
	public boolean isValid() { return hasValidSFFHeader; }

    /** Helper method to read the SFF common header. 
     * 
     * <p>This is a helper method that is invoked only once from the 
     * constructor to read the SFF header.  This method reads and 
     * validates the SFF header.  In addition, it saves the necessary 
     * information from the header into various instance variables. 
     * To fully understand the operations in this method you must 
     * review the SFF header format at: 
     * http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=formats#sff</p> 
     * 
     * <p>This method first reads the standard 31-bytes that the SFF 
     * file absolutely must have as a part of the SFF header.  Once
     * the 31-bytes have been validated, this method positions the 
     * file pointer right after the common header section.</p>
     * 
     * <p><b>Note:</b> This method must be called only once right after 
     * the file is opened.</p>
     * 
     * @throws IOException Throws IOException if the header is invalid
     * or if it could not be read successfully. 
     */
	private void loadSFFHeader() throws IOException {
	    // Flag the file as being invalid to make logic and immediate exit
	    // easier in the code below.
	    hasValidSFFHeader = false;
	    // We assume that the file pointer is at the beginning of the
	    // file. The file must start with the magic_number field
	    // value is 0x2E736666, the uint32_t encoding of the string ".sff"
	    final int signature = sffFile.readInt();
	    if (signature != 0x2E736666) {
	        // Does not have valid .sff signature.
	        throw new IOException("The SFF file did not have a valid '.sff' signature");
	    }
	    // Verify version is 1.
	    final int version = sffFile.readInt();
	    if (version != 1) {
	    	// Does not have valid version.
	    	return;
	    }
	    // Save the index offset and size so that we can skip over the
	    // index when loading sequences
	    indexOffset  = sffFile.readLong();
	    indexSize    = sffFile.readInt();
	    // Save the number of reads for future use.
	    readCount    = sffFile.readInt();
	    pendingReads = readCount;
	    // Read the header length and key length for reference below
	    final int headerSize = sffFile.readShort();
	    // We don't save key length as we don't really need it.
	    sffFile.readShort();
	    // Save the number of flows per read for future use.
	    flowsPerRead = sffFile.readShort();
	    // Now skip the unread bytes in the header and position the file
	    // pointer at the first read header section.
	    if (sffFile.skipBytes(headerSize - 30) != headerSize - 30) {
	    	throw new IOException("Invalid SFF header encountered.");
	    }
	    // The SFF file seems valid.
	    hasValidSFFHeader = true;
	    // Track the number of bytes read so far.
	    bytesRead = headerSize;
    }

    /** Determine number of reads (aka sequences/fragments) yet to be 
     * read from the file. 
     * 
     * This method can be used to determine the number of reads yet 
     * to be read/processed from the SFF file.
     * 
     * @return The number of pending reads. This method returns zero 
     * if no more reads are pending.
     */
	public int getPendingReads() { return pendingReads; }

    /** Read the next read from the SFF file.
     * 
     * <p>This method must be used to obtain the next read from the SFF
     * file appropriately populated into an EST object.  This method 
     * must be invoked only if the getPendingReads() method returns a 
     * non-zero value and the isValid() method returns true.</p>
     * 
     * <p>The number of pending reads is decremented after this method call.  
     * On errors this method throws an exception and the file is deemed
     * to be invalid.
     * 
     * @return A newly created (on the heap) EST object containing
     * the next read in the SFF file.  
     */
	public EST getNextRead(int id) throws IOException {
	    if (!isValid() || (pendingReads <= 0)) {
	        // Can't read more data from the SFF file.
	        return null;
	    }
	    // Skip over the index if we are currently at the index
	    if (indexOffset == bytesRead) {
	    	// Skip over the index.
		    if (sffFile.skipBytes(indexSize) != indexSize) {
		    	throw new IOException("Unable to skip over index in SFF file");
		    }
		    // Track bytes read
		    bytesRead += indexSize;
	    }
	    // First read the fixed size portion of the read header. The order
	    // of fields is documented at:
	    // http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=formats#sff
	    // final int readHeaderLen = sffFile.readShort();
	    bytesRead                 += sffFile.readShort();
	    final int nameLen          = sffFile.readShort();
	    final int seqLen           = sffFile.readInt();
	    final int clipQualLeft     = sffFile.readShort();
	    final int clipQualRight    = sffFile.readShort();
	    final int clipAdapterLeft  = sffFile.readShort();
	    final int clipAdapterRight = sffFile.readShort();
	    // Validate name length and base pair sequence lengths.
	    if ((nameLen < 0) || (nameLen > 16000) || (seqLen < 0) ||
	        (seqLen > 32000)) {
	        // Something is fish'y here. Name appears to be longer than 16K!
	    	throw new IOException("Name and sequence length validation failed.");
	    }
	    // Now extract the name for this read
	    byte nameData[] = new byte[nameLen];
	    if (sffFile.read(nameData) != nameLen) {
	    	throw new IOException("Unable to read sequence name from SFF file");
	    }
	    String name = new String(nameData);
	    // Move the file pointer to the beginning of the read data section
	    // by skipping over any padding bytes that may be present. In
	    // addition, we skip over the flowgram values.The number of bytes
	    // of flowgram values = sizeof(unsigned short) * flowsPerRead and
	    // we need to skip the flow_index_per_base array of size seqLen
	    int bytesToSkip = pad(16 + nameLen) + (2 * flowsPerRead) + seqLen;
	    if (sffFile.skipBytes(bytesToSkip) != bytesToSkip) {
	    	throw new IOException("Unable to get to data section in SFF file");
	    }
	    // Track bytes read so far (note that header size has been accounted).
	    bytesRead += (2 * flowsPerRead) + seqLen;
	    // Read the actual sequence.
	    byte sequenceData[] = new byte[seqLen];
	    if (sffFile.read(sequenceData) != seqLen) {
	    	throw new IOException("Unable to read sequence data from SFF file");
	    }
	    String sequence = new String(sequenceData);
	    // Skip the quality scores and byte padding at the end. For this
	    // first we calculate the padding so that it aligns to 8-byte
	    // boundary.
	    final int dataPad = pad((2 * flowsPerRead) + (3 * seqLen));
	    bytesToSkip       = seqLen + dataPad;
	    if (sffFile.skipBytes(bytesToSkip) != bytesToSkip) {
	    	throw new IOException("Unable to skip to end of read in SFF file");
	    }
	    // Update number of bytes read so far
	    bytesRead += seqLen + bytesToSkip;
	    // Track the number of sequences already read
	    pendingReads--;

	    // Now clip out adapter sequences and low quality reads from the
	    // sequence using the data in the rawReadHeader:
	    // The rules for handling the above quality and adapter ranges are
	    // a bit involved but documented at:
	    // http://www.ncbi.nlm.nih.gov/Traces/trace.cgi?cmd=show&f=formats&m=doc&s=formats#sff
	    final int leftIndex  = Math.max(1, Math.max(clipQualLeft,
	                                                clipAdapterLeft)) - 1;
	    final int rightIndex = Math.min((clipQualRight == 0 ?
	                                     seqLen : clipQualRight),
	                                    (clipAdapterRight == 0 ?
	                                     seqLen : clipAdapterRight));
	    // Save only the sequence between leftIndex and rightIndex
	    sequence = sequence.substring(leftIndex, rightIndex);
	    // Convert the information to a valid EST entry.
	    return new EST(id, name, sequence);	    
	}

	/** 
	 * Helper method to compute the padding bytes needed so that the number
	 * will be an integral multiple of 8.
	 * 
	 * This is just a convenience method to compute the padding bytes to
	 * be added or skipped to align with an integral multiple of 8. 
	 * The last modulo with 8 handles the case where x is already a multiple
	 *  of 8 to get the padding bytes to be zero.
	 *  
	 * @param value The value from which the padding to be added is to
	 * be computed.
	 * 
	 * @return The number of bytes to be added as padding. This value
	 * is in the range 0 to 7.
	 */
	private int pad(final int value) {
		return (8 - (value % 8)) % 8;
	}
	
    /** The actual input stream from where the SFF data is being read. 
     * 
     * This stream is initialized in the constructor when the SFFReader
     * is created.  This stream is opened as a binary stream. 
     */
	private DataInputStream sffFile;

	/** Flag to indicate if this file has a valid SFF header. 
	 * 
	 * This flag is set in the loadSFFHeader() method to indicate if 
	 * a valid SFF header was read from the input stream. 
	 */
	private boolean hasValidSFFHeader;

	/** Number of reads (aka fragments/sequences) in the SFF file. 
	 * 
	 * This instance variable contains the number of reads in the SFF 
	 * file.  This value is set when the SFF header is loaded by the 
	 * loadSFFHeader() method.
	 */
	private int readCount;

	/** Instance variable to track the number of reads yet to be read.
	 * 
	 * This instance variable is initialized to the number of reads 
	 * in a SFF file. Each time a sequence is read, this value is 
	 * decremented.  When this value reaches zero then all the 
	 * sequences in the SFF file have been read.
	 */
	private int pendingReads;

	/** The number of flow entries for each read in the SFF file. 
	 * 
	 * This instance variable contains the number of flows per read 
	 * in the SFF file.  This value is set when the SFF header is 
	 * loaded by the loadSFFHeader() method.  This value is used to 
	 * skip over the flowgram values in the getNextRead() method.
	 */
	private short flowsPerRead;

	/** The logical file offset where an index is stored. 
	 * 
	 * This instance variable contains the logical offset within the 
	 * SFF file where an index is stored.  This value is set when the 
	 * SFF header is loaded by the loadSFFHeader() method.  This 
	 * value is used to skip over the index in the getNextRead() method.
	 */
	private long indexOffset;

	/** The size (in number of bytes) of the index.
	 * 
	 * This instance variable contains the size (in number of bytes) 
	 * within the SFF file where an index is stored.  This value is 
	 * set when the SFF header is loaded by the loadSFFHeader() 
	 * method.  This value is used to skip over the index in the 
	 * getNextRead() method.
	 */
	private int indexSize;
	
	/**
	 * Instance variable to track the bytes read thus far.
	 * 
	 * This instance variable is used to keep track of the number of
	 * bytes that have been read so far from the SFF file. This information
	 * is essentially used skip over the index when the index offset
	 * is reached.
	 */
	private long bytesRead;
	
	public static void main(String args[]) throws IOException {
		SFFReader reader = new SFFReader("/home/dmadhava/WindowsShare/temp/CFCN.sff");
		PrintWriter outFile = new PrintWriter(new FileOutputStream("CFCN_test.fasta"));
		while (reader.getPendingReads() > 0) {
			EST est = reader.getNextRead(1);
			outFile.println(">" + est.getInfo());
			outFile.println(est.getSequence());
		}
		outFile.close();
	}
}
