#ifndef MATCHER_CPP
#define MATCHER_CPP

//--------------------------------------------------------------------
//
// This file is part of PEACE.
// 
// PEACE is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// PEACE is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with PEACE.  If not, see <http://www.gnu.org/licenses/>.
// 
// Miami University makes no representations or warranties about the
// suitability of the software, either express or implied, including
// but not limited to the implied warranties of merchantability,
// fitness for a particular purpose, or non-infringement.  Miami
// University shall not be liable for any damages suffered by licensee
// as a result of using, result of using, modifying or distributing
// this software or its derivatives.
//
// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the
// U.S., and the terms of GNU General Public License (version 3).
//
// Authors:   Dhananjai M. Rao          raodm@muohio.edu
//
//---------------------------------------------------------------------

#include "Matcher.h"
#include "Common.h"
#include "FASTAFile.h"
#include "HeuristicChain.h"
#include "AlignmentAlgorithm.h"

#include <iterator>
#include <sstream>

bool
Matcher::parseArgs(int& argc, char *argv[], ArgParser& ap,
                   Matcher::CmdLineArgs& cmdListArgs) {
    bool showOptions = false;
    // Create the list of valid arguments to be used by the ArgParser.
    ArgParser::ArgRecord arg_list[] = {
        {"--srcFile", "FASTA file with source gene sequences to match contigs",
         &cmdListArgs.srcFileName, ArgParser::STRING},
        {"--contigFile", "FASTA file with contigs generated by assembler",
         &cmdListArgs.contigFileName, ArgParser::STRING},
        {"--srcList", "List of source genes to match contigs against",
         &cmdListArgs.srcGeneList, ArgParser::STRING_LIST},
        {"--contigList", "List of generated contigs",
         &cmdListArgs.contigList, ArgParser::STRING_LIST},
        {"--options", "Lists options for this tool",
         &showOptions, ArgParser::BOOLEAN},
        {"", "", NULL, ArgParser::INVALID}
    };
    // Get the argument parser to parse and consume the global
    // options.  Based on the options supplied, various variables will
    // be set to appropriate values.
    Tool::addCmdLineArgs("Matcher", ap);
    ap.addValidArguments(arg_list);
    ap.parseArguments(argc, argv, false);
    if (showOptions) {
        std::cout << ap << std::endl;
        // Nothing further to be done.
        return false;
    }
    // Continue further
    return true;
}

bool
Matcher::validateArgs(const Matcher::CmdLineArgs& cla, ArgParser& ap) {
    // Ensure we have all the necessary parameters.
    const std::string tool = "Matcher";
    CHECK_ARGS(tool, (cla.srcFileName.empty() && cla.srcGeneList.empty()),
               "FASTA file or source list of reference genes was not "  \
               "specified.\nUse --srcFile or --srcList options.\n");
    CHECK_ARGS(tool, (cla.contigFileName.empty() && cla.contigList.empty()),
               "FASTA file with assembler-generated contigs was not "   \
               "secpfied.\nUse --contigFile or --contigList options.\n");
    CHECK_ARGS(tool, (!cla.srcFileName.empty() && !cla.srcGeneList.empty()),
               "Both --srcFile and --srcList list cannot be simultaneously"  \
               "specified.\nUse only one of the two options.\n");
    CHECK_ARGS(tool, (!cla.contigFileName.empty() && !cla.contigList.empty()),
               "Both --contigFile and --contigList cannot be simultaneously" \
               "specified.\nUse either --contigFile or --contigList "\
               "options.\n");
    // Arguments check out fine.
    return true;
}

int
Matcher::main(int argc, char *argv[]) {
    // Parse in various command line args
    ArgParser   ap;
    CmdLineArgs cmdLineArgs;
    if (!parseArgs(argc, argv, ap, cmdLineArgs)) {
        // Proceed no further.
        return 0;
    }
    // Validate the command line arguments
    if (!validateArgs(cmdLineArgs, ap)) {
        // Command-line arguments were not valid
        return 1;
    }
    // Create a Mather object and setup entries
    Matcher matcher;
    matcher.addEntries(cmdLineArgs.srcGeneList, cmdLineArgs.contigList);
    if (!matcher.loadData(cmdLineArgs.srcFileName,
                          cmdLineArgs.contigFileName)) {
        // Error loading data from FASTA files. Bil out.
        return 2;
    }
    // Do matching
    matcher.match();
    // Print N50 score
    matcher.computeN50();
    // Everything went well.
    return 0;
}

void
Matcher::computeN50() {
    // N50 is applicable only if we have at least 1 read.
    if (contigList.size() < 1) {
        // Nothing to compute here.
        return;
    }
    // To compute N50 we need sizes of contigs sorted in descending order.
    // For this first we gather the contig sizes in an vector and track
    // total length.
    std::vector<int> contigSizes(contigList.size());
    long totalContigLen = 0;
    for(int contigIdx = 0; (contigIdx < contigList.size()); contigIdx++) {
        const int contigLen    = contigList.get(contigIdx)->getSequenceLength();
        contigSizes[contigIdx] = contigLen;
        totalContigLen        += contigLen;
    }
    // Now sort the vector in descending order.
    std::sort(contigSizes.begin(), contigSizes.end(), std::greater<int>());
    // Now find the entry in the sorted list such that sum up to that
    // entry exceeds 50% of total contig length.
    const long halfContLen = totalContigLen / 2;
    long  sumLenSoFar      = 0;
    size_t index           = 0;
    while ((sumLenSoFar < halfContLen) && (index < contigSizes.size())) {
        sumLenSoFar += contigSizes[index];
        index++;
    }
    // Print the statistics out 
    std::cout << "N50 length = "    << contigSizes[index - 1]
              << ", N50  = " << index << std::endl;
}

void
Matcher::match() {
    HeuristicChain chain;
    chain.setupChain("uv-tv");
    chain.setESTList(&srcGeneList);
    // Initialize the heuristic chain.
    if (!chain.initialize()) {
        std::cerr << "HeuristicChain initialization failed.\nAborting.\n";
        return;
    }
    // The following alignment class is used to perform global
    // alignments in the nested loop below.
    const AlignmentAlgorithm aa;
    // For each contig we search and find the best source
    // gene/transcript using needleman-wunsch global alignment
    for(int contigIdx = 0; (contigIdx < contigList.size()); contigIdx++) {
        const EST* const contig     = contigList.get(contigIdx);
        const std::string contigSeq = contig->getSequence();
        // Setup reference sequence for heuristics to work with.
        chain.setReferenceEST(contig);

        // We use the following variables to track the best global
        // alignment score between the contig and the reference
        // genes/transcripts in the loop below.
        const EST* bestGene = NULL; // Best reference gene/transcript entry
        int bestScore       = -1;   // Best alignment score
        int bestAScore    = -1;     // Best a-score.
        std::string bestContig;     // Aligned assembler-generated contig
        std::string bestRefGene;    // The reference gene/transcript
        
        for(int srcIdx = 0; (srcIdx < srcGeneList.size()); srcIdx++) {
            const EST* const gene = srcGeneList.get(srcIdx);
            if (!chain.shouldAnalyze(gene)) {
                // Heuristics say it is not worth running global
                // alignment on this pair. So skip them to make things
                // faster.
            }
            // Get the current NW score for this pair.
            int score = 0;
            int aScore = 0;
            std::string contigAligned, geneAligned;
            if (aa.getNWAlignment(gene->getSequence(), contigSeq, score, aScore,
                                  geneAligned, contigAligned) > bestScore) {
                // Found a good/better matching source contig. Track it.
                bestGene    = gene;
                bestScore   = score;
                bestAScore  = aScore;
                bestContig  = contigAligned;
                bestRefGene = geneAligned;
            }
        }
        if (contigIdx == 0) {
            // Print column header to make the output a bit more readable
            std::cout << "Index, Contig ID, Gene ID, Cont.Len, NW Score, "
                      << "A-Score, Cont. Seq, Gene Seq" << std::endl;
        }
        // When control drops here we have done our best to try and
        // match the contig against all the reference genes and we
        // have tracked the best alignment we found. So print it.
        std::cout << contig->getID() << ", " << contig->getInfo()
                  << ", " << bestGene->getInfo()
                  << ", " << contig->getSequenceLength()
                  << ", " << bestScore  << ", " << bestAScore
                  << ", " << bestContig << ", "
                  << bestRefGene << std::endl;
    }
}

void
Matcher::addEntries(const ArgParser::StringList& seqList,
                    const ArgParser::StringList& contigs) {
    ASSERT( srcGeneList.size() == 0 );
    for(size_t entry = 0; (entry < seqList.size()); entry++) {
        std::ostringstream seqIdentifier;
        seqIdentifier << "SrcSeq#" << entry;
        srcGeneList.add(entry, seqIdentifier.str(), seqList[entry]);
    }
    ASSERT( contigList.size() == 0 );
    for(size_t entry = 0; (entry < contigs.size()); entry++) {
        std::ostringstream contigIdentifier;
        contigIdentifier << "Contig#" << entry;
        contigList.add(entry, contigIdentifier.str(), contigs[entry]);
    }
}

bool
Matcher::loadData(const std::string& srcFileName,
                  const std::string& estFileName) {
    // Load the source genes/transcripts from the specified file.
    if (!srcFileName.empty() && !loadData(srcFileName, srcGeneList)) {
        // Error loading source data.
        return false;
    }
    // Next load the contigs
    if (!estFileName.empty() && !loadData(estFileName, contigList)) {
        // Error loading contig data
        return false;
    }
    // All the data was loaded successfully from the data files
    return true;
}

bool
Matcher::loadData(const std::string& dataFileName, ESTList& estList) {
    // Open FASTA file for reading sequences.
    FASTAFile inputFile(dataFileName);
    if (!inputFile.good()) {
        std::cerr << "Invalid file name or the file '" << dataFileName
                  << "' is not a valid FASTA file."    << std::endl;
        return false;
    }
    // File was opened successfully. Setup options
    inputFile.setOptions(false, true);  // noMaskBases, randomizeNbases
    // Try loading fragments from this file into the est list
    const int ESTStartID = estList.size();
    for(int index = 0; ((inputFile.good()) && inputFile.hasNextEntry());
        index++) {
        // Read the next entry from the file
        EST *est = inputFile.getNextEntry(index + ESTStartID);
        if (est == NULL) {
            // Huh. error occured when loading EST. Exit ASAP.
            std::cerr << "Error reading cDNA fragment from data file: "
                      << inputFile.getFileName() << std::endl;
            return false;
        }
        // Add it to our est list.
        estList.add(est->getID(), est->getInfo(), est->getSequence());
        // We no longer need the entry from the file
        delete est;
    }
    // Return true if the file is still good at the end of processing
    // all the entries in the input file.
    return inputFile.good();
}

#endif
